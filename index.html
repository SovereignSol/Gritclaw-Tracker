<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Monk KI Tracker</title>

    <style>
      :root {
        --bg: #0b0f14;
        --text: #e9eef5;
        --muted: #97a6b8;
        --border: #223041;
        --btn: rgba(26, 39, 53, 0.9);
        --btnHover: rgba(34, 52, 71, 0.95);
        --danger: #ff6b6b;
        --ok: #7ce6a5;
        --buff: #6dff8f;
      }

      * { box-sizing: border-box; }

      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        background: var(--bg);
        color: var(--text);
        min-height: 100vh;
      }

      .wrap {
        max-width: 1100px;
        margin: 0 auto;
        padding: 22px 16px 56px;
      }

      .header h1 {
        margin: 0 0 6px;
        font-size: 28px;
        letter-spacing: 0.2px;
      }

      .sub { margin: 0; color: var(--muted); }

      .card {
        margin-top: 14px;
        padding: 14px;
        border-radius: 14px;
        border: 1px solid var(--border);
        background: rgba(18, 26, 35, 0.88);
        backdrop-filter: blur(2px);
      }

      .row {
        display: grid;
        grid-template-columns: 1fr 150px;
        gap: 12px;
        align-items: center;
      }

      .label { color: var(--muted); font-size: 14px; }

      input[type="number"], input[type="text"] {
        width: 100%;
        padding: 10px 10px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: rgba(15, 22, 32, 0.95);
        color: var(--text);
        outline: none;
      }

      .topStats {
        margin-top: 12px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 860px) {
        .topStats { grid-template-columns: 1fr 1fr 1fr; }
      }

      .statBox {
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 12px;
        background: rgba(0,0,0,0.18);
      }
      .statLabel { font-size: 12px; color: var(--muted); display: flex; align-items: center; gap: 8px; }
      .statValue { margin-top: 4px; font-size: 18px; font-weight: 650; }

      .acBuffTag {
        display: none;
        font-size: 13px;
        font-weight: 900;
        color: var(--buff);
        text-shadow: 0 0 8px rgba(109,255,143,0.35);
      }
      .acBuffTag.show { display: inline; }

      .kiHeader {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 12px;
        margin-top: 6px;
      }
      .kiTitle { font-size: 18px; font-weight: 650; }
      .kiNumbers { color: var(--muted); font-size: 14px; }

      .kiBar {
        margin-top: 12px;
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 10px;
        background: rgba(0,0,0,0.18);
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(44px, 1fr));
        gap: 8px;
      }

      .kiOrb {
        width: 44px;
        height: 44px;
        display: grid;
        place-items: center;
        border-radius: 12px;
        overflow: hidden;
        border: 1px solid rgba(255,255,255,0.06);
        background: rgba(0,0,0,0.25);
      }

      .kiOrb img {
        width: 44px;
        height: 44px;
        object-fit: cover;
        display: block;
      }

      .controls {
        margin-top: 12px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }

      .btn {
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: var(--btn);
        color: var(--text);
        cursor: pointer;
        user-select: none;
      }
      .btn:hover { background: var(--btnHover); }
      .btn:disabled { opacity: 0.45; cursor: not-allowed; }

      .qBtn {
        width: 40px;
        height: 40px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: rgba(0,0,0,0.12);
        color: var(--text);
        cursor: pointer;
        font-weight: 800;
      }
      .qBtn:hover { background: rgba(255,255,255,0.06); }

      .statusBar {
        margin-top: 10px;
        min-height: 18px;
        font-size: 13px;
        color: var(--muted);
        white-space: pre-wrap;
      }
      .statusBar.ok { color: var(--ok); }
      .statusBar.error { color: var(--danger); }

      .sectionTitle {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 12px;
      }
      .sectionTitle h2 { margin: 0; font-size: 18px; }

      /* Action Economy */
      .economyWrap {
        margin-top: 12px;
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 10px;
        background: rgba(0,0,0,0.18);
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }

      .econRow {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 900px) {
        .econRow { grid-template-columns: 210px 1fr; align-items: center; }
      }

      .econLeft {
        display: flex;
        align-items: center;
        gap: 10px;
        color: var(--muted);
        font-size: 13px;
      }

      .econIcon {
        width: 44px;
        height: 44px;
        border-radius: 12px;
        overflow: hidden;
        border: 1px solid rgba(255,255,255,0.06);
        background: rgba(0,0,0,0.25);
        display: grid;
        place-items: center;
        flex: 0 0 auto;
      }
      .econIcon img {
        width: 44px;
        height: 44px;
        object-fit: cover;
        display: block;
      }

      .econBtns {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      /* Health + AC */
      .hpGrid {
        margin-top: 12px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 860px) {
        .hpGrid { grid-template-columns: 1fr 1fr 1fr 1fr; }
      }

      .hpControls {
        margin-top: 10px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 860px) {
        .hpControls { grid-template-columns: 1fr 1fr 1fr auto; align-items: end; }
      }

      /* Mutations */
      .abilityGrid {
        margin-top: 12px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 900px) {
        .abilityGrid { grid-template-columns: 1fr 1fr; }
      }

      .abilityCard {
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 12px;
        background: rgba(0,0,0,0.18);
        display: grid;
        grid-template-columns: 56px 1fr auto;
        gap: 12px;
        align-items: center;
        position: relative;
        overflow: hidden;
      }

      .abilityActIcon {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 26px;
        height: 26px;
        border-radius: 8px;
        overflow: hidden;
        border: 1px solid rgba(255,255,255,0.06);
        background: rgba(0,0,0,0.25);
      }
      .abilityActIcon img {
        width: 26px;
        height: 26px;
        object-fit: cover;
        display: block;
      }

      .abilityIcon {
        width: 56px;
        height: 56px;
        border-radius: 14px;
        overflow: hidden;
        background: rgba(0,0,0,0.25);
        border: 1px solid rgba(255,255,255,0.06);
        display: grid;
        place-items: center;
      }
      .abilityIcon img {
        width: 56px;
        height: 56px;
        object-fit: cover;
        display: block;
      }

      .missingIcon {
        font-size: 11px;
        color: var(--muted);
        padding: 6px;
        text-align: center;
        line-height: 1.2;
      }

      .abilityName { font-weight: 700; letter-spacing: 0.2px; }
      .abilityMeta { margin-top: 4px; font-size: 13px; color: var(--muted); }
      .abilityBtns { display: flex; gap: 8px; align-items: center; }

      select {
        padding: 10px 10px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: rgba(15, 22, 32, 0.95);
        color: var(--text);
        outline: none;
      }

      /* Stable Mutations list */
      .refList {
        margin-top: 12px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 900px) {
        .refList { grid-template-columns: 1fr 1fr; }
      }

      .refItem {
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 12px;
        background: rgba(0,0,0,0.18);
      }

      .refHead {
        display: flex;
        justify-content: space-between;
        gap: 12px;
        align-items: baseline;
      }
      .refName { font-weight: 700; }
      .refMeta { color: var(--muted); font-size: 13px; white-space: nowrap; }
      .refDesc {
        margin-top: 6px;
        color: var(--muted);
        font-size: 13px;
        line-height: 1.45;
        white-space: pre-wrap;
      }

      dialog {
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 0;
        background: rgba(15, 22, 32, 0.98);
        color: var(--text);
        max-width: 900px;
        width: calc(100% - 24px);
      }
      dialog::backdrop { background: rgba(0,0,0,0.65); }

      .dlgHead {
        padding: 14px 14px 10px;
        border-bottom: 1px solid var(--border);
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 12px;
      }
      .dlgTitle { margin: 0; font-size: 18px; }

      .dlgBody { padding: 14px; }
      .dlgBody p { margin: 0 0 10px; line-height: 1.5; white-space: pre-wrap; }
      .dlgMeta { margin-top: 8px; color: var(--muted); font-size: 13px; }

      .dlgActions {
        padding: 12px 14px 14px;
        border-top: 1px solid var(--border);
        display: flex;
        justify-content: flex-end;
        gap: 10px;
      }

      .popupGrid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 900px) {
        .popupGrid { grid-template-columns: 1fr 1fr; }
      }

      .popupSection {
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 12px;
        background: rgba(0,0,0,0.18);
      }
      .popupSectionTitle {
        margin: 0 0 10px;
        font-size: 14px;
        color: var(--muted);
      }

      .popupBtns {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      /* Calculator popup */
      .calcDisplayBox {
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 10px;
        background: rgba(15, 22, 32, 0.95);
      }
      .calcExpr {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 14px;
        color: var(--muted);
        min-height: 18px;
        white-space: pre-wrap;
        word-break: break-word;
      }
      .calcResult {
        margin-top: 6px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 22px;
        font-weight: 800;
        color: var(--text);
        white-space: pre-wrap;
        word-break: break-word;
      }
      .calcGrid {
        margin-top: 12px;
        display: grid;
        grid-template-columns: repeat(4, minmax(56px, 1fr));
        gap: 10px;
      }
      .calcKey {
        padding: 14px 10px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: rgba(26, 39, 53, 0.85);
        color: var(--text);
        cursor: pointer;
        font-weight: 750;
        text-align: center;
        user-select: none;
      }
      .calcKey:hover { background: var(--btnHover); }
      .calcKey.wide { grid-column: span 2; }
      .calcKey.danger { color: #fff; background: rgba(255, 107, 107, 0.25); }
      .calcKey.ok { color: #06120b; background: rgba(124, 230, 165, 0.95); border-color: rgba(124, 230, 165, 0.35); }
      .calcKey.ok:hover { filter: brightness(0.95); }

      .footer {
        margin-top: 16px;
        font-size: 13px;
        color: var(--muted);
      }
    </style>
  </head>

  <body>
    <main class="wrap">
      <header class="header">
        <h1>Monk KI Tracker</h1>
      </header>

      <!-- Core -->
      <section class="card" id="coreCard" aria-label="Core">
        <div class="row">
          <label for="levelInput" class="label">Monk Level (1 to 20)</label>
          <input id="levelInput" type="number" min="1" max="20" step="1" />
        </div>

        <div class="topStats">
          <div class="statBox">
            <div class="statLabel">KI</div>
            <div class="statValue" id="kiText">0 / 0</div>
          </div>
          <div class="statBox">
            <div class="statLabel">Unarmored Movement Bonus</div>
            <div class="statValue" id="moveText">-</div>
          </div>
          <div class="statBox">
            <div class="statLabel">Martial Arts Die</div>
            <div class="statValue" id="madText">1d4</div>
          </div>
        </div>

        <div class="kiHeader">
          <div class="kiTitle">KI Orbs</div>
          <div class="kiNumbers" id="kiNumbersText">0 / 0</div>
        </div>

        <div id="kiBar" class="kiBar" aria-label="KI orbs bar"></div>

        <div class="controls">
          <button id="spend1" class="btn" type="button">Spend 1 KI</button>
          <button id="gain1" class="btn" type="button">Gain 1 KI</button>
          <button id="shortRest" class="btn" type="button">Short Rest (refill KI)</button>
          <button id="longRest" class="btn" type="button">Long Rest (refill KI)</button>
          <button id="nextTurn" class="btn" type="button">Next Turn</button>
        </div>

        <!-- Action Economy (NO passive abilities here) -->
        <div class="economyWrap" aria-label="Action economy">
          <div class="econRow">
            <div class="econLeft">
              <div class="econIcon"><img id="iconAction" alt="Action" /></div>
              <div>Action</div>
            </div>
            <div class="econBtns">
              <button id="basicAttack" class="btn" type="button">Basic Attack</button>
              <button id="actionOptions" class="btn" type="button">Additional Options</button>
            </div>
          </div>

          <div class="econRow">
            <div class="econLeft">
              <div class="econIcon"><img id="iconBonus" alt="Bonus action" /></div>
              <div>Bonus Action</div>
            </div>
            <div class="econBtns">
              <button id="offhandAttack" class="btn" type="button">Offhand Attack</button>
              <button id="bonusOptions" class="btn" type="button">Additional Options</button>
            </div>
          </div>

          <div class="econRow">
            <div class="econLeft">
              <div class="econIcon"><img id="iconReaction" alt="Reaction" /></div>
              <div>Reaction</div>
            </div>
            <div class="econBtns">
              <button id="oppAttack" class="btn" type="button">Attack of Opportunity</button>
              <button id="readiedAttack" class="btn" type="button">Readied Attack</button>
              <button id="readiedInfo" class="qBtn" type="button" aria-label="Readied action details">?</button>
              <button id="reactionOptions" class="btn" type="button">Additional Options</button>
            </div>
          </div>
        </div>

        <div id="statusBar" class="statusBar" role="status" aria-live="polite"></div>
      </section>

      <!-- Health + AC -->
      <section class="card" id="combatCard" aria-label="Health and AC">
        <div class="sectionTitle">
          <h2>Health and AC</h2>
          <div class="sub"></div>
        </div>

        <div class="hpGrid">
          <div class="statBox">
            <div class="statLabel">Current HP</div>
            <div class="statValue" id="hpNowText">0</div>
          </div>
          <div class="statBox">
            <div class="statLabel">Max HP</div>
            <div class="statValue" id="hpMaxText">0</div>
          </div>
          <div class="statBox">
            <div class="statLabel">Temp HP</div>
            <div class="statValue" id="hpTempText">0</div>
          </div>
          <div class="statBox">
            <div class="statLabel">
              AC <span class="acBuffTag" id="acBuffTag">+2</span>
            </div>
            <div class="statValue" id="acText">10</div>
          </div>
        </div>

        <div class="hpControls">
          <div>
            <label class="label" for="hpMaxInput">Set Max HP</label>
            <input id="hpMaxInput" type="number" min="0" step="1" />
          </div>
          <div>
            <label class="label" for="hpTempInput">Set Temp HP</label>
            <input id="hpTempInput" type="number" min="0" step="1" />
          </div>
          <div>
            <label class="label" for="acInput">Set AC</label>
            <input id="acInput" type="number" min="0" step="1" />
          </div>
          <div class="controls" style="margin-top:0">
            <button id="hpFull" class="btn" type="button">Full Heal</button>
            <button id="hpZeroTemp" class="btn" type="button">Clear Temp</button>
            <button id="openCalc" class="btn" type="button">Open Calculator</button>
          </div>
        </div>
      </section>

      <!-- Mutations -->
      <section class="card" id="mutationsCard" aria-label="Mutations">
        <div class="sectionTitle">
          <h2>Mutations</h2>
          <div class="sub">Tap Use to spend KI and consume action economy, tap ? for details.</div>
        </div>
        <div id="abilityGrid" class="abilityGrid"></div>
      </section>

      <!-- Stable Mutations -->
      <section class="card" id="stableCard" aria-label="Stable Mutations">
        <div class="sectionTitle">
          <h2>Stable Mutations</h2>
          <div class="sub">Reference and reminders, these are not spending KI unless noted.</div>
        </div>
        <div id="refList" class="refList"></div>
      </section>

      <footer class="footer">Saved in your browser (localStorage).</footer>

      <!-- Generic info dialog -->
      <dialog id="infoDialog" aria-label="Info dialog">
        <div class="dlgHead">
          <h3 class="dlgTitle" id="dlgTitle">Info</h3>
          <button class="qBtn" id="dlgX" type="button" aria-label="Close dialog">×</button>
        </div>
        <div class="dlgBody">
          <p id="dlgDesc"></p>
          <div class="dlgMeta" id="dlgMeta"></div>
        </div>
        <div class="dlgActions">
          <button class="btn" id="dlgClose" type="button">Close</button>
        </div>
      </dialog>

      <!-- Options popup -->
      <dialog id="optionsDialog" aria-label="Additional options dialog">
        <div class="dlgHead">
          <h3 class="dlgTitle" id="optTitle">Additional Options</h3>
          <button class="qBtn" id="optX" type="button" aria-label="Close dialog">×</button>
        </div>
        <div class="dlgBody">
          <div class="popupGrid">
            <div class="popupSection" id="optSectionGeneric">
              <div class="popupSectionTitle" id="optGenericTitle">Generic</div>
              <div class="popupBtns" id="optGenericBtns"></div>
            </div>

            <div class="popupSection">
              <div class="popupSectionTitle">Mutations</div>
              <div class="popupBtns" id="optMutationBtns"></div>
            </div>

            <div class="popupSection">
              <div class="popupSectionTitle">Stable Mutations</div>
              <div class="popupBtns" id="optStableBtns"></div>
            </div>
          </div>
          <div class="statusBar" id="optStatus" role="status" aria-live="polite"></div>
        </div>
        <div class="dlgActions">
          <button class="btn" id="optClose" type="button">Close</button>
        </div>
      </dialog>

      <!-- Calculator popup -->
      <dialog id="calcDialog" aria-label="Calculator dialog">
        <div class="dlgHead">
          <h3 class="dlgTitle">Calculator</h3>
          <button class="qBtn" id="calcX" type="button" aria-label="Close dialog">×</button>
        </div>
        <div class="dlgBody">
          <div class="calcDisplayBox">
            <div class="calcExpr" id="calcExpr"></div>
            <div class="calcResult" id="calcResult">0</div>
          </div>

          <div class="controls" style="margin-top: 12px">
            <button id="applyAsDamage" class="btn" type="button">Apply Result as Damage</button>
            <button id="applyAsHeal" class="btn" type="button">Apply Result as Healing</button>
            <button id="calcCopy" class="btn" type="button">Copy Result</button>
          </div>

          <div class="calcGrid" id="calcGrid">
            <button class="calcKey danger" data-k="C" type="button">C</button>
            <button class="calcKey" data-k="(" type="button">(</button>
            <button class="calcKey" data-k=")" type="button">)</button>
            <button class="calcKey" data-k="⌫" type="button">⌫</button>

            <button class="calcKey" data-k="7" type="button">7</button>
            <button class="calcKey" data-k="8" type="button">8</button>
            <button class="calcKey" data-k="9" type="button">9</button>
            <button class="calcKey" data-k="/" type="button">÷</button>

            <button class="calcKey" data-k="4" type="button">4</button>
            <button class="calcKey" data-k="5" type="button">5</button>
            <button class="calcKey" data-k="6" type="button">6</button>
            <button class="calcKey" data-k="*" type="button">×</button>

            <button class="calcKey" data-k="1" type="button">1</button>
            <button class="calcKey" data-k="2" type="button">2</button>
            <button class="calcKey" data-k="3" type="button">3</button>
            <button class="calcKey" data-k="-" type="button">−</button>

            <button class="calcKey wide" data-k="0" type="button">0</button>
            <button class="calcKey" data-k="." type="button">.</button>
            <button class="calcKey" data-k="+" type="button">+</button>

            <button class="calcKey ok wide" data-k="=" type="button">=</button>
          </div>

          <div class="statusBar" id="calcStatus" role="status" aria-live="polite"></div>
        </div>
        <div class="dlgActions">
          <button class="btn" id="calcClose" type="button">Close</button>
        </div>
      </dialog>
    </main>

    <script>
      "use strict";

      const PATHS = {
        iconsBase: "./Icons/",
        uiBase: "./UI/",
      };

      const FILES = {
        uiBackgroundCandidates: ["UI background.webp", "UI_background.webp", "UI background.webP", "UI_background.webP"],
        kiAvailable: "available_KI.webp",
        kiSpent: "spent_KI.webp",
      };

      const ICONS = {
        action: "Action.webp",
        bonus: "Bonus_action.webp",
        reaction: "Reaction.webp",
        actionUsed: "Action_used.webp",
        bonusUsed: "Bonus_action_used.webp",
        reactionUsed: "Reaction_used.webp",
      };

      const STORAGE_KEY = "monk_ki_tracker_state_v8_controlled_adaptation_calc";

      function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
      function nint(v, fallback = 0) {
        const x = Number(v);
        return Number.isFinite(x) ? Math.trunc(x) : fallback;
      }

      function getMaxKI(level) {
        level = Number(level);
        if (!Number.isFinite(level)) return 0;
        if (level <= 1) return 0;
        return clamp(level, 2, 20);
      }

      function getProfBonus(level) {
        level = clamp(nint(level, 1), 1, 20);
        if (level <= 4) return 2;
        if (level <= 8) return 3;
        if (level <= 12) return 4;
        if (level <= 16) return 5;
        return 6;
      }

      const UNARMORED_MOVE = [
        "-", "+10 ft.", "+10 ft.", "+10 ft.", "+10 ft.",
        "+15 ft.", "+15 ft.", "+15 ft.", "+15 ft.",
        "+20 ft.", "+20 ft.", "+20 ft.", "+20 ft.",
        "+25 ft.", "+25 ft.", "+25 ft.", "+25 ft.",
        "+30 ft.", "+30 ft.", "+30 ft."
      ];

      const MARTIAL_DIE = [
        "1d4","1d4","1d4","1d4",
        "1d6","1d6","1d6","1d6","1d6","1d6",
        "1d8","1d8","1d8","1d8","1d8","1d8",
        "1d10","1d10","1d10","1d10"
      ];

      const READIED_TEXT =
`Readied action (Ready -> then react later)
- On your turn, you use your ACTION to Ready something instead of doing it now.
- You must pick:
  1) A clear trigger (example: “When the ogre steps through the doorway…”), and
  2) The exact response (example: “…I shoot it with my bow,” or “…I move behind the pillar.”).
- Before the start of your next turn, if the trigger happens, you can use your REACTION to perform the readied response.
- If the trigger never happens (or you choose not to react), the readied action is lost when your next turn starts.
- If you Ready a SPELL, you cast it on your turn and hold it (concentration required), then release it with your reaction when the trigger happens. If you don’t release it, the spell slot is still spent.`;

      // Mutations
      const KI_ABILITIES = [
        { id: "extra_arms", name: "Extra Arms", icon: "Extra_arms.webp", level: 2, cost: 1, actionType: "bonus",
          desc: "Immediately after you take the Attack action on your turn, you can spend 1 ki point to make 4 unarmed strikes as a bonus action." },

        { id: "patient_defense", name: "Patient Defense", icon: "Patient_Defense.webp", level: 2, cost: 1, actionType: "bonus",
          desc: "You can spend 1 ki point to take the Dodge action as a bonus action on your turn." },

        { id: "step_of_the_wind", name: "Step of the Wind", icon: "Step_wind.webp", level: 2, cost: 1, actionType: "bonus",
          desc: "You can spend 1 ki point to take the Disengage or Dash action as a bonus action on your turn, and your jump distance is doubled for the turn." },

        { id: "reflexive_tendril", name: "Reflexive Tendril", icon: "Reflexive_Tendril.webp", level: 3, cost: 1, actionType: "reaction",
          desc:
`You can use your reaction to deflect or catch the missile when you are hit by a ranged weapon attack. When you do so, the damage you take from the attack is reduced by 1d10 + your Dexterity modifier + your monk level.

If you reduce the damage to 0, you can catch the missile if it is small enough for you to hold in one hand and you have at least one hand free. If you catch a missile in this way, you can spend 1 ki point to make a ranged attack with a range of 20/60 using the weapon or piece of ammunition you just caught, as part of the same reaction. You make this attack with proficiency, regardless of your weapon proficiencies, and the missile counts as a monk weapon for the attack.` },

        // Controlled Adaptation: stores a % reduction for the next calculator damage apply
        { id: "controlled_adaptation", name: "Controlled Adaptation", icon: "Controlled_adaptation.webp", level: 3, cost: 1, actionType: "reaction", oncePerShortRest: true,
          desc:
`You can draw upon your controlled mutation to endure extreme conditions. You gain advantage on ability checks made to withstand harsh environmental effects, such as extreme heat or cold, altitude changes, thin air, crushing pressure, or similar natural hazards.

Additionally once per short rest, with your reaction, you may spend 1 Ki point to reduce the next incoming damage by a percentage (rounded up).` },

        { id: "mantis_reach", name: "Mantis Reach", icon: "Mantis_reach.webp", level: 3, cost: 1, actionType: "bonus",
          desc:
`You momentarily alter the length and tension of your forearms, mimicking the explosive striking posture of a mantis.
As a bonus action, you may spend 1 ki point. Until the end of your turn:

• Your reach with unarmed strikes increases by 5 feet` },

        { id: "hardened_skin", name: "Hardened Skin", icon: "Hardened_skin.webp", level: 3, cost: 0, actionType: "reaction", grantsAcBuff: 2, buffUntilNextTurn: true,
          desc:
`Through intense discipline, you force your body to reinforce itself in an instant.
Reaction. Until the end of your next turn, you gain:

• +2 bonus to AC` },

        { id: "healing_factor", name: "Healing Factor", icon: "healing_factor.webp", level: 4, cost: 2, actionType: "action", healsFromMartialDie: true,
          desc:
`As an action, you can spend 2 ki points and roll a Martial Arts die. You regain a number of hit points equal to the number rolled plus your proficiency bonus.` },

        { id: "stunning_strike", name: "Stunning Strike", icon: "Stunning_strike.webp", level: 5, cost: 1, actionType: "reaction",
          desc: "You interfere with the flow of ki in an opponent's body. When you hit another creature with a melee weapon attack, you can spend 1 ki point to attempt a stunning strike. The target must succeed on a Constitution saving throw or be stunned until the end of your next turn." },

        { id: "focused_aim", name: "Focused Aim", icon: "Focused_aim.webp", level: 5, costOptions: [1,2,3], actionType: "reaction",
          desc: "When you miss with an attack roll, you can spend 1 to 3 ki points to increase your attack roll by 2 for each of these ki points you spend, potentially turning the miss into a hit." },

        { id: "adaptive_physiology", name: "Adaptive Physiology", icon: "Adaptive_physiology.webp", level: 14, cost: 1, actionType: "reaction",
          desc:
`This grants you proficiency in all saving throws.

Additionally, whenever you make a saving throw and fail, you can spend 1 ki point to reroll it and take the second result.` },

        { id: "chromatophore_bloom", name: "Chromatophore Bloom", icon: "Chromatophore_Bloom.webp", level: 18, cost: 4, actionType: "action",
          desc: "You can use your action to spend 4 ki points to become invisible for 1 minute. During that time, you also have resistance to all damage but force damage." },

        { id: "separation_body_soul", name: "Separation of Body and Soul", icon: "separation_body_soul.webp", level: 18, cost: 8, actionType: "action",
          desc: "You can spend 8 ki points to cast the astral projection spell, without needing material components. When you do so, you can't take any other creatures with you." },

        // New mutation: Primal Swarm
        { id: "primal_swarm", name: "Primal Swarm", icon: "Swarm_of_rats.webp", level: 1, cost: 0, actionType: "action", oncePerLongRest: true,
          desc:
`Once per long rest
Being more connected to their non-mutated brethren, Ninkilim can call upon a swarm of rats anywhere rats would likely be found (cities, jungles, forests, grasslands, swamps, ruins, and similar environments).

As an action, you summon a Swarm of Rats (as per the Monster Manual), which appears in an unoccupied space within 30 feet of you.

The swarm acts immediately after your turn and follows your mental commands for 1 minute. You can command them verbally (no action required) to: Move, Attack, Help a creature within 5 feet of them, disengage.` },
      ];

      // Stable Mutations (reference)
      const STABLE_MUTATIONS = [
        { id: "tenacious_gnaw", level: 1, name: "Tenacious Gnaw", actionType: "action", rest: "none",
          desc:
`As an action, you can attempt to chew through nonmagical materials a real-world rat could reasonably damage, such as:
Wood, rope, leather
thin/damaged metal (locks, thin bars, soft alloys, rusted)
softer stone plaster, weak mortar, sandstone, etc.

Chewing through such materials takes 1 minute for rope or thin wood, and 5–10 minutes for sturdier materials (DM discretion)` },

        { id: "burrow_digging", level: 1, name: "Burrow Digging", actionType: "passive", rest: "none",
          desc: "Advantage on checks that have to do with digging" },

        { id: "urban_instinct", level: 1, name: "Urban Instinct", actionType: "passive", rest: "none",
          desc: "Gain advantage on perception checks involving traps and scanning urban environments." },

        { id: "unarmored_move_feat", level: 2, name: "Unarmored Movement (feature reminder)", actionType: "passive", rest: "none",
          desc:
`Your speed increases by 10 feet while you are not wearing armor or wielding a shield. This bonus increases when you reach certain monk levels, as shown in the Monk table.

At 9th level, you gain the ability to move along vertical surfaces and across liquids on your turn without falling during the move.` },

        { id: "adaptive_landing", level: 4, name: "Adaptive Landing Reflex", actionType: "reaction", rest: "none",
          desc: "You can use your reaction when you fall to reduce any falling damage you take by an amount equal to five times your monk level." },

        { id: "extra_attack", level: 5, name: "Extra Attack", actionType: "passive", rest: "none",
          desc: "Beginning at 5th level, you can attack twice, instead of once, whenever you take the Attack action on your turn." },

        { id: "evasion", level: 7, name: "Evasion", actionType: "passive", rest: "none",
          desc: "When you are subjected to an effect that allows you to make a Dexterity saving throw to take only half damage, you instead take no damage if you succeed on the saving throw, and only half damage if you fail." },

        { id: "stillness", level: 7, name: "Stillness of Mind", actionType: "action", rest: "none",
          desc: "You can use your action to end one effect on yourself that is causing you to be charmed or frightened." },

        { id: "purity", level: 10, name: "Purity of Body", actionType: "passive", rest: "none",
          desc: "Your mastery of the ki flowing through you makes you immune to disease and poison." },

        { id: "tongue", level: 13, name: "Tongue of the Sun and Moon", actionType: "passive", rest: "none",
          desc: "You understand all spoken languages. Moreover, any creature that can understand a language can understand what you say." },

        { id: "timeless", level: 15, name: "Timeless Body", actionType: "passive", rest: "none",
          desc: "You suffer none of the frailty of old age, and you can't be aged magically. You can still die of old age. In addition, you no longer need food or water." },

        { id: "perfect_self", level: 20, name: "Perfect Self", actionType: "passive", rest: "none",
          desc: "When you roll for initiative and have no ki points remaining, you regain 4 ki points." },
      ];

      function preload(url) {
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => resolve({ ok: true, url });
          img.onerror = () => resolve({ ok: false, url });
          img.src = url;
        });
      }

      async function resolveFirstWorking(base, candidates) {
        for (const name of candidates) {
          const url = base + name;
          const r = await preload(url);
          if (r.ok) return url;
        }
        return null;
      }

      const el = {};
      let state = loadState();

      function loadState() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) {
            return {
              level: 2,
              ki: 2,
              hpNow: 10,
              hpMax: 10,
              hpTemp: 0,
              acBase: 10,

              actionUsed: false,
              bonusUsed: false,
              reactionUsed: false,
              attacksUsed: 0,

              hardenedSkinActive: false,

              // per-rest locks
              controlledAdaptationUsed: false,
              primalSwarmUsed: false,

              // Controlled Adaptation pending damage reduction
              pendingDamagePct: 0, // 0 means none

              // calculator
              calcExpr: "",
              calcResult: "0",
            };
          }
          const p = JSON.parse(raw);
          return {
            level: clamp(nint(p.level, 2), 1, 20),
            ki: Math.max(0, nint(p.ki, 2)),
            hpNow: Math.max(0, nint(p.hpNow, 10)),
            hpMax: Math.max(0, nint(p.hpMax, 10)),
            hpTemp: Math.max(0, nint(p.hpTemp, 0)),
            acBase: Math.max(0, nint(p.acBase ?? p.ac, 10)),

            actionUsed: !!p.actionUsed,
            bonusUsed: !!p.bonusUsed,
            reactionUsed: !!p.reactionUsed,
            attacksUsed: Math.max(0, nint(p.attacksUsed, 0)),

            hardenedSkinActive: !!p.hardenedSkinActive,

            controlledAdaptationUsed: !!p.controlledAdaptationUsed,
            primalSwarmUsed: !!p.primalSwarmUsed,

            pendingDamagePct: Math.max(0, Math.min(100, Number(p.pendingDamagePct) || 0)),

            calcExpr: typeof p.calcExpr === "string" ? p.calcExpr : "",
            calcResult: typeof p.calcResult === "string" ? p.calcResult : "0",
          };
        } catch {
          return {
            level: 2, ki: 2,
            hpNow: 10, hpMax: 10, hpTemp: 0,
            acBase: 10,
            actionUsed: false, bonusUsed: false, reactionUsed: false, attacksUsed: 0,
            hardenedSkinActive: false,
            controlledAdaptationUsed: false,
            primalSwarmUsed: false,
            pendingDamagePct: 0,
            calcExpr: "", calcResult: "0",
          };
        }
      }

      function saveState(s) { localStorage.setItem(STORAGE_KEY, JSON.stringify(s)); }

      function normalize() {
        state.level = clamp(nint(state.level, 1), 1, 20);
        const maxKi = getMaxKI(state.level);
        state.ki = clamp(nint(state.ki, 0), 0, maxKi);

        state.hpMax = Math.max(0, nint(state.hpMax, 0));
        state.hpNow = clamp(nint(state.hpNow, 0), 0, state.hpMax);
        state.hpTemp = Math.max(0, nint(state.hpTemp, 0));

        state.acBase = Math.max(0, nint(state.acBase, 10));
        state.attacksUsed = Math.max(0, nint(state.attacksUsed, 0));

        state.pendingDamagePct = Math.max(0, Math.min(100, Number(state.pendingDamagePct) || 0));

        if (typeof state.calcExpr !== "string") state.calcExpr = "";
        if (typeof state.calcResult !== "string") state.calcResult = "0";
      }

      function setStatus(msg, kind = "") {
        el.statusBar.textContent = msg || "";
        el.statusBar.classList.remove("ok", "error");
        if (kind) el.statusBar.classList.add(kind);
      }

      function setOptStatus(msg, kind = "") {
        el.optStatus.textContent = msg || "";
        el.optStatus.classList.remove("ok", "error");
        if (kind) el.optStatus.classList.add(kind);
      }

      function setCalcStatus(msg, kind = "") {
        el.calcStatus.textContent = msg || "";
        el.calcStatus.classList.remove("ok", "error");
        if (kind) el.calcStatus.classList.add(kind);
      }

      async function setBackground() {
        const bgUrl = await resolveFirstWorking(PATHS.uiBase, FILES.uiBackgroundCandidates);
        if (bgUrl) {
          document.body.style.backgroundImage = `url("${bgUrl}")`;
          document.body.style.backgroundRepeat = "no-repeat";
          document.body.style.backgroundPosition = "center top";
          document.body.style.backgroundAttachment = "fixed";
          document.body.style.backgroundSize = "cover";
        } else {
          document.body.style.backgroundImage = "none";
        }
      }

      function getMaxAttacksPerTurn() {
        return state.level >= 5 ? 2 : 1;
      }

      function renderTopStats() {
        const max = getMaxKI(state.level);
        el.kiText.textContent = `${state.ki} / ${max}`;
        el.kiNumbersText.textContent = `${state.ki} / ${max}`;

        const idx = clamp(state.level, 1, 20) - 1;
        el.moveText.textContent = UNARMORED_MOVE[idx] || "-";
        el.madText.textContent = MARTIAL_DIE[idx] || "1d4";
      }

      function renderCombat() {
        el.hpNowText.textContent = String(state.hpNow);
        el.hpMaxText.textContent = String(state.hpMax);
        el.hpTempText.textContent = String(state.hpTemp);
        el.acText.textContent = String(state.acBase);

        el.acBuffTag.classList.toggle("show", state.hardenedSkinActive);

        el.hpMaxInput.value = String(state.hpMax);
        el.hpTempInput.value = String(state.hpTemp);
        el.acInput.value = String(state.acBase);
      }

      function renderKIBar() {
        const max = getMaxKI(state.level);
        el.kiBar.innerHTML = "";

        const availUrl = PATHS.uiBase + FILES.kiAvailable;
        const spentUrl = PATHS.uiBase + FILES.kiSpent;

        for (let i = 1; i <= max; i++) {
          const orb = document.createElement("div");
          orb.className = "kiOrb";
          const img = document.createElement("img");
          img.loading = "lazy";
          img.referrerPolicy = "no-referrer";
          img.src = (i <= state.ki) ? availUrl : spentUrl;
          orb.appendChild(img);
          el.kiBar.appendChild(orb);
        }

        el.spend1.disabled = state.ki <= 0;
        el.gain1.disabled = state.ki >= max;
      }

      function updateEconomyIcons() {
        el.iconAction.src = PATHS.iconsBase + (state.actionUsed ? ICONS.actionUsed : ICONS.action);
        el.iconBonus.src = PATHS.iconsBase + (state.bonusUsed ? ICONS.bonusUsed : ICONS.bonus);
        el.iconReaction.src = PATHS.iconsBase + (state.reactionUsed ? ICONS.reactionUsed : ICONS.reaction);
      }

      function renderEconomyButtons() {
        const maxAttacks = getMaxAttacksPerTurn();
        el.basicAttack.disabled = state.attacksUsed >= maxAttacks;
        el.actionOptions.disabled = state.actionUsed;
        el.offhandAttack.disabled = state.bonusUsed;
        el.bonusOptions.disabled = state.bonusUsed;
        el.oppAttack.disabled = state.reactionUsed;
        el.readiedAttack.disabled = state.reactionUsed;
        el.reactionOptions.disabled = state.reactionUsed;
      }

      function openDialog(title, desc, meta) {
        el.dlgTitle.textContent = title;
        el.dlgDesc.textContent = desc;
        el.dlgMeta.textContent = meta || "";
        if (typeof el.infoDialog.showModal === "function") el.infoDialog.showModal();
        else alert(`${title}\n\n${desc}\n\n${meta || ""}`);
      }

      function spendKI(amount) {
        normalize();
        amount = nint(amount, 0);
        if (amount <= 0) return true;
        if (state.ki < amount) return false;
        state.ki -= amount;
        return true;
      }

      function applyDamage(amount) {
        amount = Math.max(0, Number(amount) || 0);
        if (amount <= 0) return { usedTemp: 0, usedHp: 0, reduced: 0, pct: 0 };

        // Controlled Adaptation applies here to the NEXT damage applied via calculator
        let reduced = 0;
        let pct = 0;
        if (state.pendingDamagePct > 0) {
          pct = state.pendingDamagePct;
          reduced = Math.ceil(amount * (pct / 100));
          amount = Math.max(0, amount - reduced);
          state.pendingDamagePct = 0; // consume it
        }

        const usedTemp = Math.min(state.hpTemp, amount);
        state.hpTemp -= usedTemp;

        const remaining = amount - usedTemp;
        const usedHp = Math.min(state.hpNow, remaining);
        state.hpNow -= usedHp;

        return { usedTemp, usedHp, reduced, pct };
      }

      function applyHeal(amount) {
        amount = Math.max(0, Number(amount) || 0);
        if (amount <= 0) return 0;
        const before = state.hpNow;
        state.hpNow = Math.min(state.hpMax, state.hpNow + amount);
        return state.hpNow - before;
      }

      function refillKI(isShortOrLongRest = false) {
        const max = getMaxKI(state.level);
        state.ki = max;
        if (isShortOrLongRest) {
          state.controlledAdaptationUsed = false;
          state.primalSwarmUsed = false;
          state.pendingDamagePct = 0;
        }
        saveState(state);
        render();
        setStatus("KI refilled.", "ok");
      }

      function nextTurn() {
        state.actionUsed = false;
        state.bonusUsed = false;
        state.reactionUsed = false;
        state.attacksUsed = 0;
        state.hardenedSkinActive = false;
        saveState(state);
        render();
        setStatus("Next turn: action economy refreshed.", "ok");
      }

      function consumeEconomy(kind) {
        if (kind === "action") {
          if (state.actionUsed) return false;
          state.actionUsed = true;
          return true;
        }
        if (kind === "bonus") {
          if (state.bonusUsed) return false;
          state.bonusUsed = true;
          return true;
        }
        if (kind === "reaction") {
          if (state.reactionUsed) return false;
          state.reactionUsed = true;
          return true;
        }
        return true;
      }

      function useActionAttack() {
        const maxAttacks = getMaxAttacksPerTurn();
        if (state.attacksUsed >= maxAttacks) return false;
        state.actionUsed = true;
        state.attacksUsed += 1;
        return true;
      }

      function parseDieFaces(dieStr) {
        const m = String(dieStr || "").match(/d(\d+)/i);
        const faces = m ? nint(m[1], 0) : 0;
        return faces > 0 ? faces : 4;
      }

      function rollDie(faces) {
        faces = Math.max(1, nint(faces, 4));
        return 1 + Math.floor(Math.random() * faces);
      }

      /* ---------- Calculator (safe eval) ---------- */
      function renderCalculator() {
        el.calcExpr.textContent = state.calcExpr || "";
        el.calcResult.textContent = state.calcResult || "0";
      }

      function sanitizeExpr(expr) {
        if (typeof expr !== "string") return "";
        return expr.replace(/[^0-9+\-*/().\s]/g, "");
      }

      function safeEval(expr) {
        const s = sanitizeExpr(expr).trim();
        if (!s) return { ok: true, value: 0, expr: "" };

        let bal = 0;
        for (const ch of s) {
          if (ch === "(") bal++;
          if (ch === ")") bal--;
          if (bal < 0) return { ok: false, error: "Mismatched parentheses." };
        }
        if (bal !== 0) return { ok: false, error: "Mismatched parentheses." };

        if (/[*\/+\-]{3,}/.test(s)) return { ok: false, error: "Invalid operator sequence." };

        try {
          const fn = new Function(`"use strict"; return (${s});`);
          const v = fn();
          if (!Number.isFinite(v)) return { ok: false, error: "Result is not a finite number." };
          return { ok: true, value: v, expr: s };
        } catch {
          return { ok: false, error: "Invalid expression." };
        }
      }

      function setCalcResultFromExpr() {
        const r = safeEval(state.calcExpr);
        if (!r.ok) {
          state.calcResult = "ERR";
          setCalcStatus(r.error, "error");
          renderCalculator();
          return;
        }
        state.calcResult = String(r.value);
        setCalcStatus("");
        renderCalculator();
      }

      function calcPress(key) {
        if (key === "C") {
          state.calcExpr = "";
          state.calcResult = "0";
          setCalcStatus("");
          saveState(state);
          renderCalculator();
          return;
        }
        if (key === "⌫") {
          state.calcExpr = (state.calcExpr || "").slice(0, -1);
          saveState(state);
          setCalcResultFromExpr();
          saveState(state);
          return;
        }
        if (key === "=") {
          const r = safeEval(state.calcExpr);
          if (!r.ok) {
            state.calcResult = "ERR";
            setCalcStatus(r.error, "error");
            saveState(state);
            renderCalculator();
            return;
          }
          state.calcExpr = String(r.value);
          state.calcResult = String(r.value);
          setCalcStatus("");
          saveState(state);
          renderCalculator();
          return;
        }

        state.calcExpr = sanitizeExpr((state.calcExpr || "") + key);
        saveState(state);
        setCalcResultFromExpr();
        saveState(state);
      }

      function getCalcNumericResult() {
        const r = safeEval(state.calcExpr);
        if (!r.ok) return { ok: false, error: r.error };
        return { ok: true, value: r.value };
      }

      /* ---------- Mutations and Stable Mutations rendering ---------- */

      function actionTypeIcon(actionType) {
        if (actionType === "bonus") return ICONS.bonus;
        if (actionType === "reaction") return ICONS.reaction;
        return ICONS.action;
      }

      function actionTypeLabel(actionType) {
        if (actionType === "bonus") return "Bonus Action";
        if (actionType === "reaction") return "Reaction";
        if (actionType === "action") return "Action";
        return "Passive";
      }

      function stableMetaText(r) {
        const parts = [];
        parts.push(actionTypeLabel(r.actionType || "passive"));
        if (r.rest && r.rest !== "none") parts.push(r.rest);
        return parts.join(" | ");
      }

      function canUseMutation(a) {
        if (a.oncePerShortRest && a.id === "controlled_adaptation" && state.controlledAdaptationUsed) return false;
        if (a.oncePerLongRest && a.id === "primal_swarm" && state.primalSwarmUsed) return false;

        if (a.actionType === "action") {
          if (state.actionUsed) return false;
        }
        if (a.actionType === "bonus") {
          if (state.bonusUsed) return false;
        }
        if (a.actionType === "reaction") {
          if (state.reactionUsed) return false;
        }

        const minCost = a.costOptions ? Math.min(...a.costOptions) : (a.cost || 0);
        if (state.ki < minCost) return false;

        return true;
      }

      async function handleMutationUse(a, chosenCost, statusSink = "main") {
        const setSinkStatus = (msg, kind) => {
          if (statusSink === "options") setOptStatus(msg, kind);
          else setStatus(msg, kind);
        };

        if (a.actionType === "action") {
          if (!consumeEconomy("action")) { setSinkStatus("Action already used this turn.", "error"); return; }
        }
        if (a.actionType === "bonus") {
          if (!consumeEconomy("bonus")) { setSinkStatus("Bonus action already used this turn.", "error"); return; }
        }
        if (a.actionType === "reaction") {
          if (!consumeEconomy("reaction")) { setSinkStatus("Reaction already used this turn.", "error"); return; }
        }

        const cost = nint(chosenCost, 0);
        if (!spendKI(cost)) {
          if (a.actionType === "action") state.actionUsed = false;
          if (a.actionType === "bonus") state.bonusUsed = false;
          if (a.actionType === "reaction") state.reactionUsed = false;
          setSinkStatus(`Not enough KI (need ${cost}).`, "error");
          saveState(state);
          await render();
          return;
        }

        // Controlled Adaptation: store percent for next calculator damage application
        if (a.id === "controlled_adaptation") {
          const pctStr = prompt("Controlled Adaptation: enter damage reduction percentage (0 to 100).");
          let pct = Number(pctStr);
          if (!Number.isFinite(pct)) pct = 0;
          pct = Math.max(0, Math.min(100, pct));

          state.pendingDamagePct = pct;
          state.controlledAdaptationUsed = true;

          saveState(state);
          await render();
          setSinkStatus(`Controlled Adaptation armed: next calculator damage reduced by ${pct}% (rounded up).`, "ok");
          return;
        }

        // Hardened Skin is just AC tag until next turn
        if (a.id === "hardened_skin") {
          state.hardenedSkinActive = true;
          saveState(state);
          await render();
          setSinkStatus(`${a.name} active: show +2 next to AC until Next Turn.`, "ok");
          return;
        }

        // Healing Factor
        if (a.healsFromMartialDie) {
          const idx = clamp(state.level, 1, 20) - 1;
          const dieStr = MARTIAL_DIE[idx] || "1d4";
          const faces = parseDieFaces(dieStr);
          const roll = rollDie(faces);
          const pb = getProfBonus(state.level);
          const healAmt = roll + pb;
          const healed = applyHeal(healAmt);
          saveState(state);
          await render();
          setSinkStatus(`${a.name}: rolled ${roll} on ${dieStr} + PB ${pb} = ${healAmt}, healed ${healed}.`, "ok");
          return;
        }

        // Primal Swarm once per long rest lock
        if (a.id === "primal_swarm") {
          state.primalSwarmUsed = true;
          saveState(state);
          await render();
          setSinkStatus(`${a.name} used (locked until long rest).`, "ok");
          return;
        }

        saveState(state);
        await render();
        setSinkStatus(`${a.name} used, spent ${cost} KI.`, "ok");
      }

      function renderAbilities() {
        el.abilityGrid.innerHTML = "";

        const max = getMaxKI(state.level);
        const availableAbilities = KI_ABILITIES.filter(a => state.level >= a.level);

        if (availableAbilities.length === 0) {
          const empty = document.createElement("div");
          empty.className = "sub";
          empty.textContent = "No mutations available yet.";
          el.abilityGrid.appendChild(empty);
          return;
        }

        for (const a of availableAbilities) {
          const card = document.createElement("div");
          card.className = "abilityCard";

          const actWrap = document.createElement("div");
          actWrap.className = "abilityActIcon";
          const actImg = document.createElement("img");
          actImg.alt = `${a.actionType || "action"} icon`;
          actImg.src = PATHS.iconsBase + actionTypeIcon(a.actionType || "action");
          actWrap.appendChild(actImg);

          const iconWrap = document.createElement("div");
          iconWrap.className = "abilityIcon";

          const img = document.createElement("img");
          img.alt = `${a.name} icon`;
          img.onerror = () => { iconWrap.innerHTML = `<div class="missingIcon">Missing icon<br>${a.icon}</div>`; };
          img.src = PATHS.iconsBase + a.icon;
          iconWrap.appendChild(img);

          const mid = document.createElement("div");
          const name = document.createElement("div");
          name.className = "abilityName";
          name.textContent = a.name;

          const meta = document.createElement("div");
          meta.className = "abilityMeta";
          const costMeta = a.costOptions
            ? `Cost: ${a.costOptions[0]} to ${a.costOptions[a.costOptions.length - 1]} KI`
            : `Cost: ${nint(a.cost, 0)} KI`;
          const restMeta =
            (a.oncePerShortRest) ? "Once per short rest." :
            (a.oncePerLongRest) ? "Once per long rest." : "";
          const actMeta = `Uses: ${actionTypeLabel(a.actionType || "action")}`;
          meta.textContent = [actMeta, costMeta, restMeta].filter(Boolean).join(" | ");

          mid.appendChild(name);
          mid.appendChild(meta);

          const btns = document.createElement("div");
          btns.className = "abilityBtns";

          let costPicker = null;
          if (a.costOptions && Array.isArray(a.costOptions)) {
            costPicker = document.createElement("select");
            costPicker.setAttribute("aria-label", `Choose KI cost for ${a.name}`);
            for (const c of a.costOptions) {
              const opt = document.createElement("option");
              opt.value = String(c);
              opt.textContent = `${c} KI`;
              costPicker.appendChild(opt);
            }
            btns.appendChild(costPicker);
          }

          const useBtn = document.createElement("button");
          useBtn.className = "btn";
          useBtn.type = "button";
          useBtn.textContent = "Use";
          useBtn.disabled = max === 0;

          useBtn.addEventListener("click", async () => {
            const amt = a.costOptions ? nint(costPicker.value, 0) : nint(a.cost, 0);
            if (!canUseMutation(a)) {
              const reason =
                (a.oncePerShortRest && a.id === "controlled_adaptation" && state.controlledAdaptationUsed) ? "Locked until Short/Long Rest." :
                (a.oncePerLongRest && a.id === "primal_swarm" && state.primalSwarmUsed) ? "Locked until Long Rest." :
                (a.actionType === "action" && state.actionUsed) ? "Action already used this turn." :
                (a.actionType === "bonus" && state.bonusUsed) ? "Bonus action already used this turn." :
                (a.actionType === "reaction" && state.reactionUsed) ? "Reaction already used this turn." :
                (state.ki < amt) ? `Not enough KI (need ${amt}).` :
                "Unavailable.";
              setStatus(`${a.name}: ${reason}`, "error");
              await render();
              return;
            }
            await handleMutationUse(a, amt, "main");
          });

          const q = document.createElement("button");
          q.className = "qBtn";
          q.type = "button";
          q.textContent = "?";
          q.setAttribute("aria-label", `Show details for ${a.name}`);
          q.addEventListener("click", () => {
            openDialog(a.name, a.desc, meta.textContent);
          });

          btns.appendChild(useBtn);
          btns.appendChild(q);

          card.appendChild(actWrap);
          card.appendChild(iconWrap);
          card.appendChild(mid);
          card.appendChild(btns);

          el.abilityGrid.appendChild(card);
        }

        const cards = el.abilityGrid.querySelectorAll(".abilityCard");
        const available = KI_ABILITIES.filter(a => state.level >= a.level);
        cards.forEach((card, i) => {
          const a = available[i];
          const useBtn = card.querySelector("button.btn");
          if (!useBtn || !a) return;
          useBtn.disabled = !canUseMutation(a);
        });
      }

      function renderStable() {
        el.refList.innerHTML = "";
        const available = STABLE_MUTATIONS.filter(r => state.level >= r.level);

        if (available.length === 0) {
          const empty = document.createElement("div");
          empty.className = "sub";
          empty.textContent = "No stable mutations yet.";
          el.refList.appendChild(empty);
          return;
        }

        for (const r of available) {
          const box = document.createElement("div");
          box.className = "refItem";

          const head = document.createElement("div");
          head.className = "refHead";

          const name = document.createElement("div");
          name.className = "refName";
          name.textContent = r.name;

          const meta = document.createElement("div");
          meta.className = "refMeta";
          meta.textContent = stableMetaText(r);

          head.appendChild(name);
          head.appendChild(meta);

          const desc = document.createElement("div");
          desc.className = "refDesc";
          desc.textContent = r.desc;

          box.appendChild(head);
          box.appendChild(desc);
          el.refList.appendChild(box);
        }
      }

      /* ---------- Options popup builder ---------- */

      const GENERIC_ACTION_BUTTONS = [
        { id: "dash", label: "Dash", text: "Dash (move extra up to your speed)" },
        { id: "disengage", label: "Disengage", text: "Disengage (no opportunity attacks from your movement this turn)" },
        { id: "dodge", label: "Dodge", text: "Dodge (attacks vs you have disadvantage, Dex saves have advantage)" },
        { id: "help", label: "Help", text: "Help (give an ally advantage or assist a task)" },
        { id: "hide", label: "Hide", text: "Hide (make a Stealth check to become hidden)" },
        { id: "ready", label: "Ready", text: "Ready (set a trigger, then use your reaction to act)" },
        { id: "search", label: "Search", text: "Search (make a check to find something)" },
        { id: "object", label: "Use an Object / Interact", text: "Use an Object / Interact (open a door, pull a lever, draw or stow an item, etc.)" },
        { id: "improv", label: "Improvised action", text: "Improvised actions (DM call): lift/push/drag, break/force open, swing on a rope, tip a statue, grab a ledge, etc." },
        { id: "throw", label: "Throw something", text: "Throw something (usually an improvised weapon or a thrown weapon, resolved as an attack)" },
      ];

      function openOptions(kind) {
        el.optTitle.textContent = `Additional Options (${actionTypeLabel(kind)})`;
        setOptStatus("");

        el.optGenericBtns.innerHTML = "";
        el.optStableBtns.innerHTML = "";
        el.optMutationBtns.innerHTML = "";

        if (kind === "action") {
          el.optSectionGeneric.style.display = "";
          el.optGenericTitle.textContent = "Generic actions";
          for (const g of GENERIC_ACTION_BUTTONS) {
            const b = document.createElement("button");
            b.className = "btn";
            b.type = "button";
            b.textContent = g.label;
            b.disabled = state.actionUsed;
            b.addEventListener("click", async () => {
              if (!consumeEconomy("action")) { setOptStatus("Action already used this turn.", "error"); return; }
              saveState(state);
              await render();
              setOptStatus(`Used action: ${g.text}`, "ok");
            });
            el.optGenericBtns.appendChild(b);
          }
        } else if (kind === "bonus") {
          el.optSectionGeneric.style.display = "";
          el.optGenericTitle.textContent = "Bonus actions";
          const b = document.createElement("button");
          b.className = "btn";
          b.type = "button";
          b.textContent = "Offhand Attack";
          b.disabled = state.bonusUsed;
          b.addEventListener("click", async () => {
            if (!consumeEconomy("bonus")) { setOptStatus("Bonus action already used this turn.", "error"); return; }
            saveState(state);
            await render();
            setOptStatus("Offhand Attack used (bonus action).", "ok");
          });
          el.optGenericBtns.appendChild(b);
        } else {
          el.optSectionGeneric.style.display = "";
          el.optGenericTitle.textContent = "Reactions";
          const b1 = document.createElement("button");
          b1.className = "btn";
          b1.type = "button";
          b1.textContent = "Attack of Opportunity";
          b1.disabled = state.reactionUsed;
          b1.addEventListener("click", async () => {
            if (!consumeEconomy("reaction")) { setOptStatus("Reaction already used this turn.", "error"); return; }
            saveState(state);
            await render();
            setOptStatus("Attack of Opportunity used (reaction).", "ok");
          });

          const b2 = document.createElement("button");
          b2.className = "btn";
          b2.type = "button";
          b2.textContent = "Readied Attack";
          b2.disabled = state.reactionUsed;
          b2.addEventListener("click", async () => {
            if (!consumeEconomy("reaction")) { setOptStatus("Reaction already used this turn.", "error"); return; }
            saveState(state);
            await render();
            setOptStatus("Readied Attack used (reaction).", "ok");
          });

          const q = document.createElement("button");
          q.className = "qBtn";
          q.type = "button";
          q.textContent = "?";
          q.addEventListener("click", () => openDialog("Readied Attack", READIED_TEXT, ""));

          el.optGenericBtns.appendChild(b1);
          el.optGenericBtns.appendChild(b2);
          el.optGenericBtns.appendChild(q);
        }

        // Mutation buttons matching kind
        const availMut = KI_ABILITIES.filter(a => state.level >= a.level && (a.actionType || "action") === kind);
        if (availMut.length === 0) {
          const sp = document.createElement("div");
          sp.className = "sub";
          sp.textContent = "No mutations for this action type.";
          el.optMutationBtns.appendChild(sp);
        } else {
          for (const a of availMut) {
            const b = document.createElement("button");
            b.className = "btn";
            b.type = "button";
            const costMeta = a.costOptions ? `${a.costOptions[0]}-${a.costOptions[a.costOptions.length - 1]} KI` : `${nint(a.cost,0)} KI`;
            const restMeta = a.oncePerShortRest ? " (1/Short Rest)" : (a.oncePerLongRest ? " (1/Long Rest)" : "");
            b.textContent = `${a.name} (${costMeta}${restMeta})`;
            b.disabled = !canUseMutation(a);

            b.addEventListener("click", async () => {
              let chosen = 0;
              if (a.costOptions && Array.isArray(a.costOptions)) {
                const pick = prompt(`${a.name}: choose KI cost (${a.costOptions.join(", ")}).`);
                chosen = nint(pick, a.costOptions[0]);
                if (!a.costOptions.includes(chosen)) chosen = a.costOptions[0];
              } else {
                chosen = nint(a.cost, 0);
              }

              if (!canUseMutation(a)) {
                setOptStatus(`${a.name}: not available right now.`, "error");
                await render();
                return;
              }
              await handleMutationUse(a, chosen, "options");
            });

            const q = document.createElement("button");
            q.className = "qBtn";
            q.type = "button";
            q.textContent = "?";
            q.addEventListener("click", () => {
              const metaLine = `${actionTypeLabel(a.actionType || "action")} | ${costMeta}${restMeta}`;
              openDialog(a.name, a.desc, metaLine);
            });

            el.optMutationBtns.appendChild(b);
            el.optMutationBtns.appendChild(q);
          }
        }

        // Stable mutation buttons: ONLY non-passive (per your request to remove passives from economy usage)
        const availStable = STABLE_MUTATIONS.filter(r => state.level >= r.level);
        const stableForKind = availStable.filter(r => (r.actionType || "passive") === kind);

        if (stableForKind.length === 0) {
          const sp = document.createElement("div");
          sp.className = "sub";
          sp.textContent = "No stable mutations for this action type.";
          el.optStableBtns.appendChild(sp);
        } else {
          for (const r of stableForKind) {
            const b = document.createElement("button");
            b.className = "btn";
            b.type = "button";
            const meta = stableMetaText(r);
            b.textContent = `${r.name} (${meta})`;

            const canSpend =
              (r.actionType === "action" && !state.actionUsed) ||
              (r.actionType === "bonus" && !state.bonusUsed) ||
              (r.actionType === "reaction" && !state.reactionUsed);

            b.disabled = !canSpend;

            b.addEventListener("click", async () => {
              if (!consumeEconomy(r.actionType)) {
                setOptStatus(`${actionTypeLabel(r.actionType)} already used this turn.`, "error");
                return;
              }
              saveState(state);
              await render();
              setOptStatus(`Used ${actionTypeLabel(r.actionType)} for: ${r.name}`, "ok");
            });

            const q = document.createElement("button");
            q.className = "qBtn";
            q.type = "button";
            q.textContent = "?";
            q.addEventListener("click", () => openDialog(r.name, r.desc, meta));

            el.optStableBtns.appendChild(b);
            el.optStableBtns.appendChild(q);
          }
        }

        if (typeof el.optionsDialog.showModal === "function") el.optionsDialog.showModal();
        else alert("Options dialog not supported in this browser.");
      }

      /* ---------- Main render ---------- */
      async function render() {
        normalize();
        renderTopStats();
        renderCombat();
        await setBackground();
        renderKIBar();
        updateEconomyIcons();
        renderEconomyButtons();
        renderAbilities();
        renderStable();
        renderCalculator();
        setCalcResultFromExpr();
      }

      /* ---------- Init ---------- */
      function init() {
        el.levelInput = document.getElementById("levelInput");
        el.kiText = document.getElementById("kiText");
        el.kiNumbersText = document.getElementById("kiNumbersText");
        el.moveText = document.getElementById("moveText");
        el.madText = document.getElementById("madText");
        el.kiBar = document.getElementById("kiBar");

        el.spend1 = document.getElementById("spend1");
        el.gain1 = document.getElementById("gain1");
        el.shortRest = document.getElementById("shortRest");
        el.longRest = document.getElementById("longRest");
        el.nextTurn = document.getElementById("nextTurn");
        el.statusBar = document.getElementById("statusBar");

        el.iconAction = document.getElementById("iconAction");
        el.iconBonus = document.getElementById("iconBonus");
        el.iconReaction = document.getElementById("iconReaction");

        el.basicAttack = document.getElementById("basicAttack");
        el.actionOptions = document.getElementById("actionOptions");
        el.offhandAttack = document.getElementById("offhandAttack");
        el.bonusOptions = document.getElementById("bonusOptions");
        el.oppAttack = document.getElementById("oppAttack");
        el.readiedAttack = document.getElementById("readiedAttack");
        el.readiedInfo = document.getElementById("readiedInfo");
        el.reactionOptions = document.getElementById("reactionOptions");

        el.hpNowText = document.getElementById("hpNowText");
        el.hpMaxText = document.getElementById("hpMaxText");
        el.hpTempText = document.getElementById("hpTempText");
        el.acText = document.getElementById("acText");
        el.acBuffTag = document.getElementById("acBuffTag");
        el.hpMaxInput = document.getElementById("hpMaxInput");
        el.hpTempInput = document.getElementById("hpTempInput");
        el.acInput = document.getElementById("acInput");
        el.hpFull = document.getElementById("hpFull");
        el.hpZeroTemp = document.getElementById("hpZeroTemp");
        el.openCalc = document.getElementById("openCalc");

        el.abilityGrid = document.getElementById("abilityGrid");
        el.refList = document.getElementById("refList");

        el.infoDialog = document.getElementById("infoDialog");
        el.dlgTitle = document.getElementById("dlgTitle");
        el.dlgDesc = document.getElementById("dlgDesc");
        el.dlgMeta = document.getElementById("dlgMeta");
        el.dlgClose = document.getElementById("dlgClose");
        el.dlgX = document.getElementById("dlgX");

        el.optionsDialog = document.getElementById("optionsDialog");
        el.optTitle = document.getElementById("optTitle");
        el.optGenericBtns = document.getElementById("optGenericBtns");
        el.optMutationBtns = document.getElementById("optMutationBtns");
        el.optStableBtns = document.getElementById("optStableBtns");
        el.optStatus = document.getElementById("optStatus");
        el.optClose = document.getElementById("optClose");
        el.optX = document.getElementById("optX");
        el.optSectionGeneric = document.getElementById("optSectionGeneric");
        el.optGenericTitle = document.getElementById("optGenericTitle");

        el.calcDialog = document.getElementById("calcDialog");
        el.calcExpr = document.getElementById("calcExpr");
        el.calcResult = document.getElementById("calcResult");
        el.calcStatus = document.getElementById("calcStatus");
        el.calcGrid = document.getElementById("calcGrid");
        el.applyAsDamage = document.getElementById("applyAsDamage");
        el.applyAsHeal = document.getElementById("applyAsHeal");
        el.calcCopy = document.getElementById("calcCopy");
        el.calcClose = document.getElementById("calcClose");
        el.calcX = document.getElementById("calcX");

        el.levelInput.value = String(state.level);
        el.hpMaxInput.value = String(state.hpMax);
        el.hpTempInput.value = String(state.hpTemp);
        el.acInput.value = String(state.acBase);

        el.levelInput.addEventListener("input", async () => {
          state.level = clamp(nint(el.levelInput.value, 1), 1, 20);
          const newMaxKi = getMaxKI(state.level);
          state.ki = clamp(state.ki, 0, newMaxKi);
          saveState(state);
          setStatus("");
          await render();
        });

        el.spend1.addEventListener("click", async () => {
          if (!state.ki) { setStatus("Not enough KI.", "error"); return; }
          state.ki = Math.max(0, state.ki - 1);
          saveState(state);
          await render();
          setStatus("Spent 1 KI.", "ok");
        });

        el.gain1.addEventListener("click", async () => {
          const max = getMaxKI(state.level);
          state.ki = Math.min(max, state.ki + 1);
          saveState(state);
          await render();
          setStatus("Gained 1 KI.", "ok");
        });

        el.shortRest.addEventListener("click", () => refillKI(true));
        el.longRest.addEventListener("click", () => refillKI(true));
        el.nextTurn.addEventListener("click", nextTurn);

        el.basicAttack.addEventListener("click", async () => {
          normalize();
          const ok = useActionAttack();
          if (!ok) {
            setStatus("No attacks remaining this turn.", "error");
            await render();
            return;
          }
          saveState(state);
          await render();
          const maxAttacks = getMaxAttacksPerTurn();
          setStatus(`Basic Attack used (${state.attacksUsed}/${maxAttacks}).`, "ok");
        });

        el.actionOptions.addEventListener("click", () => openOptions("action"));
        el.bonusOptions.addEventListener("click", () => openOptions("bonus"));
        el.reactionOptions.addEventListener("click", () => openOptions("reaction"));

        el.offhandAttack.addEventListener("click", async () => {
          normalize();
          if (!consumeEconomy("bonus")) {
            setStatus("Bonus action already used this turn.", "error");
            await render();
            return;
          }
          saveState(state);
          await render();
          setStatus("Offhand Attack used (bonus action).", "ok");
        });

        el.oppAttack.addEventListener("click", async () => {
          normalize();
          if (!consumeEconomy("reaction")) {
            setStatus("Reaction already used this turn.", "error");
            await render();
            return;
          }
          saveState(state);
          await render();
          setStatus("Attack of Opportunity used (reaction).", "ok");
        });

        el.readiedAttack.addEventListener("click", async () => {
          normalize();
          if (!consumeEconomy("reaction")) {
            setStatus("Reaction already used this turn.", "error");
            await render();
            return;
          }
          saveState(state);
          await render();
          setStatus("Readied Attack used (reaction).", "ok");
        });

        el.readiedInfo.addEventListener("click", () => openDialog("Readied Attack", READIED_TEXT, ""));

        el.hpMaxInput.addEventListener("input", async () => {
          state.hpMax = Math.max(0, nint(el.hpMaxInput.value, 0));
          state.hpNow = clamp(state.hpNow, 0, state.hpMax);
          saveState(state);
          await render();
        });

        el.hpTempInput.addEventListener("input", async () => {
          state.hpTemp = Math.max(0, nint(el.hpTempInput.value, 0));
          saveState(state);
          await render();
        });

        el.acInput.addEventListener("input", async () => {
          state.acBase = Math.max(0, nint(el.acInput.value, 10));
          saveState(state);
          await render();
        });

        el.hpFull.addEventListener("click", async () => {
          normalize();
          state.hpNow = state.hpMax;
          saveState(state);
          await render();
          setStatus("Healed to full.", "ok");
        });

        el.hpZeroTemp.addEventListener("click", async () => {
          normalize();
          state.hpTemp = 0;
          saveState(state);
          await render();
          setStatus("Temp HP cleared.", "ok");
        });

        el.dlgClose.addEventListener("click", () => el.infoDialog.close());
        el.dlgX.addEventListener("click", () => el.infoDialog.close());
        el.infoDialog.addEventListener("click", (e) => {
          const rect = el.infoDialog.getBoundingClientRect();
          const inside =
            e.clientX >= rect.left && e.clientX <= rect.right &&
            e.clientY >= rect.top && e.clientY <= rect.bottom;
          if (!inside) el.infoDialog.close();
        });

        el.optClose.addEventListener("click", () => el.optionsDialog.close());
        el.optX.addEventListener("click", () => el.optionsDialog.close());
        el.optionsDialog.addEventListener("click", (e) => {
          const rect = el.optionsDialog.getBoundingClientRect();
          const inside =
            e.clientX >= rect.left && e.clientX <= rect.right &&
            e.clientY >= rect.top && e.clientY <= rect.bottom;
          if (!inside) el.optionsDialog.close();
        });

        el.openCalc.addEventListener("click", () => {
          setCalcStatus(state.pendingDamagePct > 0 ? `Controlled Adaptation armed: next damage reduced by ${state.pendingDamagePct}%.` : "");
          if (typeof el.calcDialog.showModal === "function") el.calcDialog.showModal();
          else alert("Calculator dialog not supported in this browser.");
        });

        el.calcClose.addEventListener("click", () => el.calcDialog.close());
        el.calcX.addEventListener("click", () => el.calcDialog.close());
        el.calcDialog.addEventListener("click", (e) => {
          const rect = el.calcDialog.getBoundingClientRect();
          const inside =
            e.clientX >= rect.left && e.clientX <= rect.right &&
            e.clientY >= rect.top && e.clientY <= rect.bottom;
          if (!inside) el.calcDialog.close();
        });

        el.calcGrid.addEventListener("click", (e) => {
          const btn = e.target.closest("[data-k]");
          if (!btn) return;
          const k = String(btn.getAttribute("data-k") || "");
          if (!k) return;
          calcPress(k);
        });

        document.addEventListener("keydown", (e) => {
          if (!el.calcDialog.open) return;

          const k = e.key;
          const tag = (document.activeElement && document.activeElement.tagName) ? document.activeElement.tagName.toLowerCase() : "";
          if (tag === "input" || tag === "select" || tag === "textarea") return;

          if (k >= "0" && k <= "9") return calcPress(k);
          if (k === "+" || k === "-" || k === "*" || k === "/" || k === "." || k === "(" || k === ")") return calcPress(k);
          if (k === "Enter" || k === "=") { e.preventDefault(); return calcPress("="); }
          if (k === "Backspace") { e.preventDefault(); return calcPress("⌫"); }
          if (k === "Escape") { e.preventDefault(); return calcPress("C"); }
        });

        el.applyAsDamage.addEventListener("click", async () => {
          normalize();
          const r = getCalcNumericResult();
          if (!r.ok) { setCalcStatus(r.error, "error"); return; }
          const amt = Math.max(0, Number(r.value));
          const used = applyDamage(amt);
          saveState(state);
          await render();

          if (used.pct > 0) {
            setCalcStatus(`Applied ${amt} damage, reduced by ${used.pct}% (−${used.reduced}), then dealt remaining (Temp used: ${used.usedTemp}, HP used: ${used.usedHp}).`, "ok");
          } else {
            setCalcStatus(`Applied ${amt} damage (Temp used: ${used.usedTemp}, HP used: ${used.usedHp}).`, "ok");
          }
        });

        el.applyAsHeal.addEventListener("click", async () => {
          normalize();
          const r = getCalcNumericResult();
          if (!r.ok) { setCalcStatus(r.error, "error"); return; }
          const amt = Math.max(0, Number(r.value));
          const healed = applyHeal(amt);
          saveState(state);
          await render();
          setCalcStatus(`Applied ${healed} healing (capped at Max HP).`, "ok");
        });

        el.calcCopy.addEventListener("click", async () => {
          try {
            await navigator.clipboard.writeText(String(el.calcResult.textContent || "0"));
            setCalcStatus("Result copied to clipboard.", "ok");
          } catch {
            setCalcStatus("Could not copy (browser blocked clipboard).", "error");
          }
        });

        render();
      }

      document.addEventListener("DOMContentLoaded", init);
    </script>
  </body>
</html>
