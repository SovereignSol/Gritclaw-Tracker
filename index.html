<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Monk KI Tracker</title>

    <style>
      :root {
        --bg: #0b0f14;
        --text: #e9eef5;
        --muted: #97a6b8;
        --border: #223041;
        --btn: rgba(26, 39, 53, 0.9);
        --btnHover: rgba(34, 52, 71, 0.95);
        --danger: #ff6b6b;
        --ok: #7ce6a5;
        --buff: #6dff8f;
      }

      * { box-sizing: border-box; }

      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        background: var(--bg);
        color: var(--text);
        min-height: 100vh;
      }

      .wrap {
        max-width: 1100px;
        margin: 0 auto;
        padding: 22px 16px 56px;
      }

      .header h1 {
        margin: 0 0 6px;
        font-size: 28px;
        letter-spacing: 0.2px;
      }

      .sub { margin: 0; color: var(--muted); }

      .card {
        margin-top: 14px;
        padding: 14px;
        border-radius: 14px;
        border: 1px solid var(--border);
        background: rgba(18, 26, 35, 0.88);
        backdrop-filter: blur(2px);
      }

      .row {
        display: grid;
        grid-template-columns: 1fr 150px;
        gap: 12px;
        align-items: center;
      }

      .label { color: var(--muted); font-size: 14px; }

      input[type="number"], input[type="text"] {
        width: 100%;
        padding: 10px 10px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: rgba(15, 22, 32, 0.95);
        color: var(--text);
        outline: none;
      }

      .topStats {
        margin-top: 12px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 860px) {
        .topStats { grid-template-columns: 1fr 1fr 1fr; }
      }

      .statBox {
        position: relative;
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 12px;
        background: rgba(0,0,0,0.18);
        overflow: hidden;
      }
      .statLabel { font-size: 12px; color: var(--muted); }
      .statValue { margin-top: 4px; font-size: 18px; font-weight: 650; }

      .acBadge {
        position: absolute;
        top: 8px;
        right: 10px;
        font-size: 13px;
        font-weight: 900;
        color: var(--buff);
        display: none;
        text-shadow: 0 0 8px rgba(109,255,143,0.35);
      }
      .acBadge.show { display: inline; }

      .kiHeader {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 12px;
        margin-top: 6px;
      }
      .kiTitle { font-size: 18px; font-weight: 650; }
      .kiNumbers { color: var(--muted); font-size: 14px; }

      .kiBar {
        margin-top: 12px;
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 10px;
        background: rgba(0,0,0,0.18);
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(44px, 1fr));
        gap: 8px;
      }

      .kiOrb {
        width: 44px;
        height: 44px;
        display: grid;
        place-items: center;
        border-radius: 12px;
        overflow: hidden;
        border: 1px solid rgba(255,255,255,0.06);
        background: rgba(0,0,0,0.25);
      }

      .kiOrb img {
        width: 44px;
        height: 44px;
        object-fit: cover;
        display: block;
      }

      .controls {
        margin-top: 12px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }

      .btn {
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: var(--btn);
        color: var(--text);
        cursor: pointer;
        user-select: none;
      }
      .btn:hover { background: var(--btnHover); }
      .btn:disabled { opacity: 0.45; cursor: not-allowed; }

      .qBtn {
        width: 40px;
        height: 40px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: rgba(0,0,0,0.12);
        color: var(--text);
        cursor: pointer;
        font-weight: 800;
      }
      .qBtn:hover { background: rgba(255,255,255,0.06); }

      .statusBar {
        margin-top: 10px;
        min-height: 18px;
        font-size: 13px;
        color: var(--muted);
        white-space: pre-wrap;
      }
      .statusBar.ok { color: var(--ok); }
      .statusBar.error { color: var(--danger); }

      .sectionTitle {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 12px;
      }
      .sectionTitle h2 { margin: 0; font-size: 18px; }

      /* Action Economy */
      .economyWrap {
        margin-top: 12px;
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 10px;
        background: rgba(0,0,0,0.18);
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }

      .econRow {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 900px) {
        .econRow { grid-template-columns: 180px 1fr; align-items: center; }
      }

      .econIcons {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }

      .econIcon {
        width: 44px;
        height: 44px;
        border-radius: 12px;
        overflow: hidden;
        border: 1px solid rgba(255,255,255,0.06);
        background: rgba(0,0,0,0.25);
        display: grid;
        place-items: center;
      }
      .econIcon img {
        width: 44px;
        height: 44px;
        object-fit: cover;
        display: block;
      }

      .econBtns {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: flex-start;
      }

      .econLabel {
        font-size: 13px;
        color: var(--muted);
      }

      /* Health + AC */
      .hpGrid {
        margin-top: 12px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 860px) {
        .hpGrid { grid-template-columns: 1fr 1fr 1fr 1fr; }
      }

      .hpControls {
        margin-top: 10px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 860px) {
        .hpControls { grid-template-columns: 1fr 1fr 1fr auto; align-items: end; }
      }

      /* Calculator */
      .calcWrap {
        margin-top: 12px;
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 12px;
        background: rgba(0,0,0,0.18);
      }
      .calcTop {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 860px) {
        .calcTop { grid-template-columns: 1fr auto; align-items: end; }
      }

      .calcDisplayBox {
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 10px;
        background: rgba(15, 22, 32, 0.95);
      }
      .calcExpr {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 14px;
        color: var(--muted);
        min-height: 18px;
        white-space: pre-wrap;
        word-break: break-word;
      }
      .calcResult {
        margin-top: 6px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 22px;
        font-weight: 800;
        color: var(--text);
        white-space: pre-wrap;
        word-break: break-word;
      }

      .calcApplyBtns {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      .calcGrid {
        margin-top: 12px;
        display: grid;
        grid-template-columns: repeat(4, minmax(56px, 1fr));
        gap: 10px;
      }

      .calcKey {
        padding: 14px 10px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: rgba(26, 39, 53, 0.85);
        color: var(--text);
        cursor: pointer;
        font-weight: 750;
        text-align: center;
        user-select: none;
      }
      .calcKey:hover { background: var(--btnHover); }
      .calcKey.wide { grid-column: span 2; }
      .calcKey.danger { color: #fff; background: rgba(255, 107, 107, 0.25); }
      .calcKey.ok { color: #06120b; background: rgba(124, 230, 165, 0.95); border-color: rgba(124, 230, 165, 0.35); }
      .calcKey.ok:hover { filter: brightness(0.95); }

      /* Mutations + Reference */
      .abilityGrid {
        margin-top: 12px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 900px) {
        .abilityGrid { grid-template-columns: 1fr 1fr; }
      }

      .abilityCard {
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 12px;
        background: rgba(0,0,0,0.18);
        display: grid;
        grid-template-columns: 56px 1fr auto;
        gap: 12px;
        align-items: center;
        position: relative;
        overflow: hidden;
      }

      .abilityActIcon {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 26px;
        height: 26px;
        border-radius: 8px;
        overflow: hidden;
        border: 1px solid rgba(255,255,255,0.06);
        background: rgba(0,0,0,0.25);
      }
      .abilityActIcon img {
        width: 26px;
        height: 26px;
        object-fit: cover;
        display: block;
      }

      .abilityIcon {
        width: 56px;
        height: 56px;
        border-radius: 14px;
        overflow: hidden;
        background: rgba(0,0,0,0.25);
        border: 1px solid rgba(255,255,255,0.06);
        display: grid;
        place-items: center;
      }
      .abilityIcon img {
        width: 56px;
        height: 56px;
        object-fit: cover;
        display: block;
      }

      .missingIcon {
        font-size: 11px;
        color: var(--muted);
        padding: 6px;
        text-align: center;
        line-height: 1.2;
      }

      .abilityName { font-weight: 700; letter-spacing: 0.2px; }
      .abilityMeta { margin-top: 4px; font-size: 13px; color: var(--muted); }
      .abilityBtns { display: flex; gap: 8px; align-items: center; }

      select {
        padding: 10px 10px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: rgba(15, 22, 32, 0.95);
        color: var(--text);
        outline: none;
      }

      .refList {
        margin-top: 12px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 900px) {
        .refList { grid-template-columns: 1fr 1fr; }
      }

      .refItem {
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 12px;
        background: rgba(0,0,0,0.18);
      }

      .refHead {
        display: flex;
        justify-content: space-between;
        gap: 12px;
        align-items: baseline;
      }
      .refName { font-weight: 700; }
      .refLevel { color: var(--muted); font-size: 13px; white-space: nowrap; }
      .refDesc {
        margin-top: 6px;
        color: var(--muted);
        font-size: 13px;
        line-height: 1.45;
        white-space: pre-wrap;
      }

      dialog {
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 0;
        background: rgba(15, 22, 32, 0.98);
        color: var(--text);
        max-width: 760px;
        width: calc(100% - 24px);
      }
      dialog::backdrop { background: rgba(0,0,0,0.65); }

      .dlgHead {
        padding: 14px 14px 10px;
        border-bottom: 1px solid var(--border);
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 12px;
      }
      .dlgTitle { margin: 0; font-size: 18px; }

      .dlgBody { padding: 14px; }
      .dlgBody p { margin: 0 0 10px; line-height: 1.5; white-space: pre-wrap; }
      .dlgMeta { margin-top: 8px; color: var(--muted); font-size: 13px; }

      .dlgActions {
        padding: 12px 14px 14px;
        border-top: 1px solid var(--border);
        display: flex;
        justify-content: flex-end;
        gap: 10px;
      }

      .footer {
        margin-top: 16px;
        font-size: 13px;
        color: var(--muted);
      }
    </style>
  </head>

  <body>
    <main class="wrap">
      <header class="header">
        <h1>Monk KI Tracker</h1>
      </header>

      <!-- Core -->
      <section class="card" id="coreCard" aria-label="Core">
        <div class="row">
          <label for="levelInput" class="label">Monk Level (1 to 20)</label>
          <input id="levelInput" type="number" min="1" max="20" step="1" />
        </div>

        <div class="topStats">
          <div class="statBox">
            <div class="statLabel">KI</div>
            <div class="statValue" id="kiText">0 / 0</div>
          </div>
          <div class="statBox">
            <div class="statLabel">Unarmored Movement Bonus</div>
            <div class="statValue" id="moveText">-</div>
          </div>
          <div class="statBox">
            <div class="statLabel">Martial Arts Die</div>
            <div class="statValue" id="madText">1d4</div>
          </div>
        </div>

        <div class="kiHeader">
          <div class="kiTitle">KI Orbs</div>
          <div class="kiNumbers" id="kiNumbersText">0 / 0</div>
        </div>

        <div id="kiBar" class="kiBar" aria-label="KI orbs bar"></div>

        <div class="controls">
          <button id="spend1" class="btn" type="button">Spend 1 KI</button>
          <button id="gain1" class="btn" type="button">Gain 1 KI</button>
          <button id="shortRest" class="btn" type="button">Short Rest (refill KI)</button>
          <button id="longRest" class="btn" type="button">Long Rest (refill KI)</button>
          <button id="nextTurn" class="btn" type="button">Next Turn</button>
        </div>

        <!-- Action Economy -->
        <div class="economyWrap" aria-label="Action economy">
          <div class="econRow">
            <div class="econLabel">Action economy</div>
            <div class="econIcons" id="econIcons"></div>
          </div>

          <div class="econRow">
            <div class="econLabel">Action</div>
            <div class="econBtns">
              <button id="basicAttack" class="btn" type="button">Basic Attack</button>
              <button id="oppAttack" class="btn" type="button">Attack of Opportunity</button>
              <button id="actionOptions" class="btn" type="button">Additional Options</button>
            </div>
          </div>

          <div class="econRow">
            <div class="econLabel">Bonus action</div>
            <div class="econBtns">
              <button id="offhandAttack" class="btn" type="button">Offhand Attack</button>
            </div>
          </div>

          <div class="econRow">
            <div class="econLabel">Reaction</div>
            <div class="econBtns">
              <button id="readiedAttack" class="btn" type="button">Readied Attack</button>
              <button id="readiedInfo" class="qBtn" type="button" aria-label="Readied action details">?</button>
            </div>
          </div>
        </div>

        <div id="statusBar" class="statusBar" role="status" aria-live="polite"></div>
      </section>

      <!-- Health + AC + Calculator -->
      <section class="card" id="combatCard" aria-label="Health, AC, and Calculator">
        <div class="sectionTitle">
          <h2>Health, AC, and Calculator</h2>
          <div class="sub"></div>
        </div>

        <div class="hpGrid">
          <div class="statBox">
            <div class="statLabel">Current HP</div>
            <div class="statValue" id="hpNowText">0</div>
          </div>
          <div class="statBox">
            <div class="statLabel">Max HP</div>
            <div class="statValue" id="hpMaxText">0</div>
          </div>
          <div class="statBox">
            <div class="statLabel">Temp HP</div>
            <div class="statValue" id="hpTempText">0</div>
          </div>
          <div class="statBox" id="acBox">
            <div class="acBadge" id="acBadge">+2</div>
            <div class="statLabel">AC</div>
            <div class="statValue" id="acText">10</div>
          </div>
        </div>

        <div class="hpControls">
          <div>
            <label class="label" for="hpMaxInput">Set Max HP</label>
            <input id="hpMaxInput" type="number" min="0" step="1" />
          </div>
          <div>
            <label class="label" for="hpTempInput">Set Temp HP</label>
            <input id="hpTempInput" type="number" min="0" step="1" />
          </div>
          <div>
            <label class="label" for="acInput">Set AC</label>
            <input id="acInput" type="number" min="0" step="1" />
          </div>
          <div class="controls" style="margin-top:0">
            <button id="hpFull" class="btn" type="button">Full Heal</button>
            <button id="hpZeroTemp" class="btn" type="button">Clear Temp</button>
          </div>
        </div>

        <div class="calcWrap" aria-label="Calculator">
          <div class="calcTop">
            <div class="calcDisplayBox">
              <div class="calcExpr" id="calcExpr"></div>
              <div class="calcResult" id="calcResult">0</div>
            </div>

            <div class="calcApplyBtns">
              <button id="applyAsDamage" class="btn" type="button">Apply Result as Damage</button>
              <button id="applyAsHeal" class="btn" type="button">Apply Result as Healing</button>
              <button id="calcCopy" class="btn" type="button">Copy Result</button>
            </div>
          </div>

          <div class="calcGrid" id="calcGrid">
            <button class="calcKey danger" data-k="C" type="button">C</button>
            <button class="calcKey" data-k="(" type="button">(</button>
            <button class="calcKey" data-k=")" type="button">)</button>
            <button class="calcKey" data-k="⌫" type="button">⌫</button>

            <button class="calcKey" data-k="7" type="button">7</button>
            <button class="calcKey" data-k="8" type="button">8</button>
            <button class="calcKey" data-k="9" type="button">9</button>
            <button class="calcKey" data-k="/" type="button">÷</button>

            <button class="calcKey" data-k="4" type="button">4</button>
            <button class="calcKey" data-k="5" type="button">5</button>
            <button class="calcKey" data-k="6" type="button">6</button>
            <button class="calcKey" data-k="*" type="button">×</button>

            <button class="calcKey" data-k="1" type="button">1</button>
            <button class="calcKey" data-k="2" type="button">2</button>
            <button class="calcKey" data-k="3" type="button">3</button>
            <button class="calcKey" data-k="-" type="button">−</button>

            <button class="calcKey wide" data-k="0" type="button">0</button>
            <button class="calcKey" data-k="." type="button">.</button>
            <button class="calcKey" data-k="+" type="button">+</button>

            <button class="calcKey ok wide" data-k="=" type="button">=</button>
          </div>

          <div class="statusBar" id="calcStatus" role="status" aria-live="polite"></div>
        </div>
      </section>

      <!-- Mutations -->
      <section class="card" id="mutationsCard" aria-label="Mutations">
        <div class="sectionTitle">
          <h2>Mutations</h2>
          <div class="sub">Tap Use to spend KI, tap ? for details.</div>
        </div>
        <div id="abilityGrid" class="abilityGrid"></div>
      </section>

      <!-- Reference -->
      <section class="card" id="referenceCard" aria-label="Reference">
        <div class="sectionTitle">
          <h2>Reference</h2>
        </div>
        <div id="refList" class="refList"></div>
      </section>

      <footer class="footer">Saved in your browser (localStorage).</footer>

      <dialog id="infoDialog" aria-label="Info dialog">
        <div class="dlgHead">
          <h3 class="dlgTitle" id="dlgTitle">Info</h3>
          <button class="qBtn" id="dlgX" type="button" aria-label="Close dialog">×</button>
        </div>
        <div class="dlgBody">
          <p id="dlgDesc"></p>
          <div class="dlgMeta" id="dlgMeta"></div>
        </div>
        <div class="dlgActions">
          <button class="btn" id="dlgClose" type="button">Close</button>
        </div>
      </dialog>

      <dialog id="optionsDialog" aria-label="Action options dialog">
        <div class="dlgHead">
          <h3 class="dlgTitle">Additional Action Options</h3>
          <button class="qBtn" id="optX" type="button" aria-label="Close dialog">×</button>
        </div>
        <div class="dlgBody">
          <p style="white-space:pre-wrap; margin:0; line-height:1.5; color: var(--muted);">
Action
- Dash (move extra up to your speed)
- Disengage (no opportunity attacks from your movement this turn)
- Dodge (attacks vs you have disadvantage, Dex saves have advantage)
- Help (give an ally advantage or assist a task)
- Hide (make a Stealth check to become hidden)
- Ready (set a trigger, then use your reaction to act)
- Search (make a check to find something)
- Use an Object / Interact (open a door, pull a lever, draw or stow an item, etc.)
- Improvised actions (DM call): lift/push/drag, break/force open, swing on a rope, tip a statue, grab a ledge, etc.
- Throw something (usually an improvised weapon or a thrown weapon, resolved as an attack)
          </p>
        </div>
        <div class="dlgActions">
          <button class="btn" id="optClose" type="button">Close</button>
        </div>
      </dialog>
    </main>

    <script>
      "use strict";

      const PATHS = {
        iconsBase: "./Icons/",
        uiBase: "./UI/",
      };

      const FILES = {
        uiBackgroundCandidates: ["UI background.webp", "UI_background.webp", "UI background.webP", "UI_background.webP"],
        kiAvailable: "available_KI.webp",
        kiSpent: "spent_KI.webp",
      };

      const ICONS = {
        action: "Action.webp",
        bonus: "Bonus_action.webp",
        reaction: "Reaction.webp",
        actionUsed: "Action_used.webp",
        bonusUsed: "Bonus_action_used.webp",
        reactionUsed: "Reaction_used.webp",
      };

      const STORAGE_KEY = "monk_ki_tracker_state_v5_economy";

      function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
      function nint(v, fallback = 0) {
        const x = Number(v);
        return Number.isFinite(x) ? Math.trunc(x) : fallback;
      }

      function getMaxKI(level) {
        level = Number(level);
        if (!Number.isFinite(level)) return 0;
        if (level <= 1) return 0;
        return clamp(level, 2, 20);
      }

      function getProfBonus(level) {
        level = clamp(nint(level, 1), 1, 20);
        if (level <= 4) return 2;
        if (level <= 8) return 3;
        if (level <= 12) return 4;
        if (level <= 16) return 5;
        return 6;
      }

      function parseDieFaces(dieStr) {
        // expects "1d4", "1d6", etc
        const m = String(dieStr || "").match(/d(\d+)/i);
        const faces = m ? nint(m[1], 0) : 0;
        return faces > 0 ? faces : 4;
      }

      function rollDie(faces) {
        faces = Math.max(1, nint(faces, 4));
        return 1 + Math.floor(Math.random() * faces);
      }

      const UNARMORED_MOVE = [
        "-", "+10 ft.", "+10 ft.", "+10 ft.", "+10 ft.",
        "+15 ft.", "+15 ft.", "+15 ft.", "+15 ft.",
        "+20 ft.", "+20 ft.", "+20 ft.", "+20 ft.",
        "+25 ft.", "+25 ft.", "+25 ft.", "+25 ft.",
        "+30 ft.", "+30 ft.", "+30 ft."
      ];

      const MARTIAL_DIE = [
        "1d4","1d4","1d4","1d4",
        "1d6","1d6","1d6","1d6","1d6","1d6",
        "1d8","1d8","1d8","1d8","1d8","1d8",
        "1d10","1d10","1d10","1d10"
      ];

      const READIED_TEXT =
`Readied action (Ready -> then react later)
- On your turn, you use your ACTION to Ready something instead of doing it now.
- You must pick:
  1) A clear trigger (example: “When the ogre steps through the doorway…”), and
  2) The exact response (example: “…I shoot it with my bow,” or “…I move behind the pillar.”).
- Before the start of your next turn, if the trigger happens, you can use your REACTION to perform the readied response.
- If the trigger never happens (or you choose not to react), the readied action is lost when your next turn starts.
- If you Ready a SPELL, you cast it on your turn and hold it (concentration required), then release it with your reaction when the trigger happens. If you don’t release it, the spell slot is still spent.`;

      // Mutations (added + restored)
      const KI_ABILITIES = [
        { id: "extra_arms", name: "Extra Arms", icon: "Extra_arms.webp", level: 2, cost: 1, actionType: "bonus",
          desc: "Immediately after you take the Attack action on your turn, you can spend 1 ki point to make 4 unarmed strikes as a bonus action." },

        { id: "patient_defense", name: "Patient Defense", icon: "Patient_Defense.webp", level: 2, cost: 1, actionType: "bonus",
          desc: "You can spend 1 ki point to take the Dodge action as a bonus action on your turn." },

        { id: "step_of_the_wind", name: "Step of the Wind", icon: "Step_wind.webp", level: 2, cost: 1, actionType: "bonus",
          desc: "You can spend 1 ki point to take the Disengage or Dash action as a bonus action on your turn, and your jump distance is doubled for the turn." },

        { id: "reflexive_tendril", name: "Reflexive Tendril", icon: "Reflexive_Tendril.webp", level: 3, cost: 1, actionType: "reaction",
          desc:
`You can use your reaction to deflect or catch the missile when you are hit by a ranged weapon attack. When you do so, the damage you take from the attack is reduced by 1d10 + your Dexterity modifier + your monk level.

If you reduce the damage to 0, you can catch the missile if it is small enough for you to hold in one hand and you have at least one hand free. If you catch a missile in this way, you can spend 1 ki point to make a ranged attack with a range of 20/60 using the weapon or piece of ammunition you just caught, as part of the same reaction. You make this attack with proficiency, regardless of your weapon proficiencies, and the missile counts as a monk weapon for the attack.` },

        { id: "controlled_adaptation", name: "Controlled Adaptation", icon: "Controlled_adaptation.webp", level: 3, cost: 1, actionType: "reaction", oncePerShortRest: true,
          desc:
`You can draw upon your controlled mutation to endure extreme conditions. You gain advantage on ability checks made to withstand harsh environmental effects, such as extreme heat or cold, altitude changes, thin air, crushing pressure, or similar natural hazards.

Additionally once per short rest, with your reaction, you may spend 1 Ki point to roll a D100 to reduce acid, cold, fire, lightning, or thunder damage by the percentage of that amount with the damage total rounded up.` },

        { id: "mantis_reach", name: "Mantis Reach", icon: "Mantis_reach.webp", level: 3, cost: 1, actionType: "bonus",
          desc:
`You momentarily alter the length and tension of your forearms, mimicking the explosive striking posture of a mantis.
As a bonus action, you may spend 1 ki point. Until the end of your turn:

• Your reach with unarmed strikes increases by 5 feet` },

        { id: "hardened_skin", name: "Hardened Skin", icon: "Hardened_skin.webp", level: 3, cost: 0, actionType: "reaction", grantsAcBuff: 2, buffUntilNextTurn: true,
          desc:
`Through intense discipline, you force your body to reinforce itself in an instant.
Reaction. Until the end of your next turn, you gain:

• +2 bonus to AC` },

        { id: "healing_factor", name: "Healing Factor", icon: "healing_factor.webp", level: 4, cost: 2, actionType: "action", healsFromMartialDie: true,
          desc:
`As an action, you can spend 2 ki points and roll a Martial Arts die. You regain a number of hit points equal to the number rolled plus your proficiency bonus.` },

        { id: "stunning_strike", name: "Stunning Strike", icon: "Stunning_strike.webp", level: 5, cost: 1, actionType: "reaction",
          desc: "You interfere with the flow of ki in an opponent's body. When you hit another creature with a melee weapon attack, you can spend 1 ki point to attempt a stunning strike. The target must succeed on a Constitution saving throw or be stunned until the end of your next turn." },

        { id: "focused_aim", name: "Focused Aim", icon: "Focused_aim.webp", level: 5, costOptions: [1,2,3], actionType: "reaction",
          desc: "When you miss with an attack roll, you can spend 1 to 3 ki points to increase your attack roll by 2 for each of these ki points you spend, potentially turning the miss into a hit." },

        { id: "adaptive_physiology", name: "Adaptive Physiology", icon: "Adaptive_physiology.webp", level: 14, cost: 1, actionType: "reaction",
          desc:
`This grants you proficiency in all saving throws.

Additionally, whenever you make a saving throw and fail, you can spend 1 ki point to reroll it and take the second result.` },

        { id: "chromatophore_bloom", name: "Chromatophore Bloom", icon: "Chromatophore_Bloom.webp", level: 18, cost: 4, actionType: "action",
          desc: "You can use your action to spend 4 ki points to become invisible for 1 minute. During that time, you also have resistance to all damage but force damage." },

        { id: "separation_body_soul", name: "Separation of Body and Soul", icon: "separation_body_soul.webp", level: 18, cost: 8, actionType: "action",
          desc: "You can spend 8 ki points to cast the astral projection spell, without needing material components. When you do so, you can't take any other creatures with you." },
      ];

      const REF_FEATURES = [
        { level: 2, name: "Unarmored Movement (feature reminder)",
          desc:
`Your speed increases by 10 feet while you are not wearing armor or wielding a shield. This bonus increases when you reach certain monk levels, as shown in the Monk table.

At 9th level, you gain the ability to move along vertical surfaces and across liquids on your turn without falling during the move.` },
        { level: 4, name: "Adaptive Landing Reflex",
          desc: "You can use your reaction when you fall to reduce any falling damage you take by an amount equal to five times your monk level." },
        { level: 5, name: "Extra Attack",
          desc: "Beginning at 5th level, you can attack twice, instead of once, whenever you take the Attack action on your turn." },
        { level: 7, name: "Evasion",
          desc: "When you are subjected to an effect that allows you to make a Dexterity saving throw to take only half damage, you instead take no damage if you succeed on the saving throw, and only half damage if you fail." },
        { level: 7, name: "Stillness of Mind",
          desc: "You can use your action to end one effect on yourself that is causing you to be charmed or frightened." },
        { level: 10, name: "Purity of Body",
          desc: "Your mastery of the ki flowing through you makes you immune to disease and poison." },
        { level: 13, name: "Tongue of the Sun and Moon",
          desc: "You understand all spoken languages. Moreover, any creature that can understand a language can understand what you say." },
        { level: 15, name: "Timeless Body",
          desc: "You suffer none of the frailty of old age, and you can't be aged magically. You can still die of old age. In addition, you no longer need food or water." },
        { level: 20, name: "Perfect Self",
          desc: "When you roll for initiative and have no ki points remaining, you regain 4 ki points." },
      ];

      function preload(url) {
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => resolve({ ok: true, url });
          img.onerror = () => resolve({ ok: false, url });
          img.src = url;
        });
      }

      async function resolveFirstWorking(base, candidates) {
        for (const name of candidates) {
          const url = base + name;
          const r = await preload(url);
          if (r.ok) return url;
        }
        return null;
      }

      const el = {};
      let state = loadState();

      function loadState() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) {
            return {
              level: 2,
              ki: 2,
              hpNow: 10,
              hpMax: 10,
              hpTemp: 0,
              acBase: 10,
              acBuff: 0,

              // action economy
              actionUsed: false,
              bonusUsed: false,
              reactionUsed: false,
              attacksUsed: 0,

              // per-rest trackers
              controlledAdaptationUsed: false,

              // calculator
              calcExpr: "",
              calcResult: "0",
            };
          }
          const p = JSON.parse(raw);
          return {
            level: clamp(nint(p.level, 2), 1, 20),
            ki: Math.max(0, nint(p.ki, 2)),
            hpNow: Math.max(0, nint(p.hpNow, 10)),
            hpMax: Math.max(0, nint(p.hpMax, 10)),
            hpTemp: Math.max(0, nint(p.hpTemp, 0)),
            acBase: Math.max(0, nint(p.acBase ?? p.ac, 10)),
            acBuff: Math.max(0, nint(p.acBuff, 0)),

            actionUsed: !!p.actionUsed,
            bonusUsed: !!p.bonusUsed,
            reactionUsed: !!p.reactionUsed,
            attacksUsed: Math.max(0, nint(p.attacksUsed, 0)),

            controlledAdaptationUsed: !!p.controlledAdaptationUsed,

            calcExpr: typeof p.calcExpr === "string" ? p.calcExpr : "",
            calcResult: typeof p.calcResult === "string" ? p.calcResult : "0",
          };
        } catch {
          return {
            level: 2, ki: 2,
            hpNow: 10, hpMax: 10, hpTemp: 0,
            acBase: 10, acBuff: 0,
            actionUsed: false, bonusUsed: false, reactionUsed: false, attacksUsed: 0,
            controlledAdaptationUsed: false,
            calcExpr: "", calcResult: "0"
          };
        }
      }

      function saveState(s) { localStorage.setItem(STORAGE_KEY, JSON.stringify(s)); }

      function normalize() {
        state.level = clamp(nint(state.level, 1), 1, 20);
        const maxKi = getMaxKI(state.level);
        state.ki = clamp(nint(state.ki, 0), 0, maxKi);

        state.hpMax = Math.max(0, nint(state.hpMax, 0));
        state.hpNow = clamp(nint(state.hpNow, 0), 0, state.hpMax);
        state.hpTemp = Math.max(0, nint(state.hpTemp, 0));

        state.acBase = Math.max(0, nint(state.acBase, 10));
        state.acBuff = Math.max(0, nint(state.acBuff, 0));

        state.attacksUsed = Math.max(0, nint(state.attacksUsed, 0));
        if (typeof state.calcExpr !== "string") state.calcExpr = "";
        if (typeof state.calcResult !== "string") state.calcResult = "0";
      }

      function setStatus(msg, kind = "") {
        el.statusBar.textContent = msg || "";
        el.statusBar.classList.remove("ok", "error");
        if (kind) el.statusBar.classList.add(kind);
      }

      function setCalcStatus(msg, kind = "") {
        el.calcStatus.textContent = msg || "";
        el.calcStatus.classList.remove("ok", "error");
        if (kind) el.calcStatus.classList.add(kind);
      }

      async function setBackground() {
        const bgUrl = await resolveFirstWorking(PATHS.uiBase, FILES.uiBackgroundCandidates);
        if (bgUrl) {
          document.body.style.backgroundImage = `url("${bgUrl}")`;
          document.body.style.backgroundRepeat = "no-repeat";
          document.body.style.backgroundPosition = "center top";
          document.body.style.backgroundAttachment = "fixed";
          document.body.style.backgroundSize = "cover";
        } else {
          document.body.style.backgroundImage = "none";
        }
      }

      function getMaxAttacksPerTurn() {
        return state.level >= 5 ? 2 : 1;
      }

      function renderTopStats() {
        const max = getMaxKI(state.level);
        el.kiText.textContent = `${state.ki} / ${max}`;
        el.kiNumbersText.textContent = `${state.ki} / ${max}`;

        const idx = clamp(state.level, 1, 20) - 1;
        el.moveText.textContent = UNARMORED_MOVE[idx] || "-";
        el.madText.textContent = MARTIAL_DIE[idx] || "1d4";
      }

      function renderCombat() {
        el.hpNowText.textContent = String(state.hpNow);
        el.hpMaxText.textContent = String(state.hpMax);
        el.hpTempText.textContent = String(state.hpTemp);

        const acTotal = state.acBase + state.acBuff;
        el.acText.textContent = String(acTotal);
        el.acBadge.classList.toggle("show", state.acBuff > 0);

        el.hpMaxInput.value = String(state.hpMax);
        el.hpTempInput.value = String(state.hpTemp);
        el.acInput.value = String(state.acBase);
      }

      function renderKIBar() {
        const max = getMaxKI(state.level);
        el.kiBar.innerHTML = "";

        const availUrl = PATHS.uiBase + FILES.kiAvailable;
        const spentUrl = PATHS.uiBase + FILES.kiSpent;

        for (let i = 1; i <= max; i++) {
          const orb = document.createElement("div");
          orb.className = "kiOrb";
          const img = document.createElement("img");
          img.loading = "lazy";
          img.referrerPolicy = "no-referrer";
          img.src = (i <= state.ki) ? availUrl : spentUrl;
          orb.appendChild(img);
          el.kiBar.appendChild(orb);
        }

        el.spend1.disabled = state.ki <= 0;
        el.gain1.disabled = state.ki >= max;
      }

      function econIcon(name, used) {
        const wrap = document.createElement("div");
        wrap.className = "econIcon";
        const img = document.createElement("img");
        img.loading = "lazy";
        img.referrerPolicy = "no-referrer";
        if (name === "action") img.src = PATHS.iconsBase + (used ? ICONS.actionUsed : ICONS.action);
        if (name === "bonus") img.src = PATHS.iconsBase + (used ? ICONS.bonusUsed : ICONS.bonus);
        if (name === "reaction") img.src = PATHS.iconsBase + (used ? ICONS.reactionUsed : ICONS.reaction);
        wrap.appendChild(img);
        return wrap;
      }

      function renderEconomy() {
        el.econIcons.innerHTML = "";
        el.econIcons.appendChild(econIcon("action", state.actionUsed));
        el.econIcons.appendChild(econIcon("bonus", state.bonusUsed));
        el.econIcons.appendChild(econIcon("reaction", state.reactionUsed));

        const maxAttacks = getMaxAttacksPerTurn();
        const actionAvailableForAttacks = !state.actionUsed || (state.actionUsed && state.attacksUsed < maxAttacks);
        el.basicAttack.disabled = !actionAvailableForAttacks || state.attacksUsed >= maxAttacks;

        el.actionOptions.disabled = state.actionUsed;

        el.offhandAttack.disabled = state.bonusUsed;
        el.oppAttack.disabled = state.reactionUsed;
        el.readiedAttack.disabled = state.reactionUsed;
      }

      function openDialog(title, desc, meta) {
        el.dlgTitle.textContent = title;
        el.dlgDesc.textContent = desc;
        el.dlgMeta.textContent = meta || "";
        if (typeof el.infoDialog.showModal === "function") el.infoDialog.showModal();
        else alert(`${title}\n\n${desc}\n\n${meta || ""}`);
      }

      function spendKI(amount) {
        normalize();
        amount = nint(amount, 0);
        if (amount <= 0) return true;
        if (state.ki < amount) return false;
        state.ki -= amount;
        return true;
      }

      function applyDamage(amount) {
        amount = Math.max(0, Number(amount) || 0);
        if (amount <= 0) return { usedTemp: 0, usedHp: 0 };

        const usedTemp = Math.min(state.hpTemp, amount);
        state.hpTemp -= usedTemp;

        const remaining = amount - usedTemp;
        const usedHp = Math.min(state.hpNow, remaining);
        state.hpNow -= usedHp;

        return { usedTemp, usedHp };
      }

      function applyHeal(amount) {
        amount = Math.max(0, Number(amount) || 0);
        if (amount <= 0) return 0;
        const before = state.hpNow;
        state.hpNow = Math.min(state.hpMax, state.hpNow + amount);
        return state.hpNow - before;
      }

      function refillKI(isShortOrLongRest = false) {
        const max = getMaxKI(state.level);
        state.ki = max;

        if (isShortOrLongRest) {
          state.controlledAdaptationUsed = false;
        }

        saveState(state);
        render();
        setStatus("KI refilled.", "ok");
      }

      function nextTurn() {
        // refresh action economy and clear "until end of next turn" buffs
        state.actionUsed = false;
        state.bonusUsed = false;
        state.reactionUsed = false;
        state.attacksUsed = 0;
        state.acBuff = 0;

        saveState(state);
        render();
        setStatus("Next turn: action economy refreshed.", "ok");
      }

      function useActionAttack() {
        const maxAttacks = getMaxAttacksPerTurn();
        if (state.attacksUsed >= maxAttacks) return false;

        state.actionUsed = true;
        state.attacksUsed += 1;

        return true;
      }

      function consumeEconomy(kind) {
        if (kind === "action") {
          if (state.actionUsed) return false;
          state.actionUsed = true;
          return true;
        }
        if (kind === "bonus") {
          if (state.bonusUsed) return false;
          state.bonusUsed = true;
          return true;
        }
        if (kind === "reaction") {
          if (state.reactionUsed) return false;
          state.reactionUsed = true;
          return true;
        }
        return true;
      }

      /* ---------- CALCULATOR (safe expression eval) ---------- */

      function renderCalculator() {
        el.calcExpr.textContent = state.calcExpr || "";
        el.calcResult.textContent = state.calcResult || "0";
      }

      function sanitizeExpr(expr) {
        if (typeof expr !== "string") return "";
        return expr.replace(/[^0-9+\-*/().\s]/g, "");
      }

      function safeEval(expr) {
        const s = sanitizeExpr(expr).trim();
        if (!s) return { ok: true, value: 0, expr: "" };

        let bal = 0;
        for (const ch of s) {
          if (ch === "(") bal++;
          if (ch === ")") bal--;
          if (bal < 0) return { ok: false, error: "Mismatched parentheses." };
        }
        if (bal !== 0) return { ok: false, error: "Mismatched parentheses." };

        if (/[*\/+\-]{3,}/.test(s)) return { ok: false, error: "Invalid operator sequence." };

        try {
          const fn = new Function(`"use strict"; return (${s});`);
          const v = fn();
          if (!Number.isFinite(v)) return { ok: false, error: "Result is not a finite number." };
          return { ok: true, value: v, expr: s };
        } catch {
          return { ok: false, error: "Invalid expression." };
        }
      }

      function setCalcResultFromExpr() {
        const r = safeEval(state.calcExpr);
        if (!r.ok) {
          state.calcResult = "ERR";
          setCalcStatus(r.error, "error");
          renderCalculator();
          return;
        }
        state.calcResult = String(r.value);
        setCalcStatus("");
        renderCalculator();
      }

      function calcPress(key) {
        if (key === "C") {
          state.calcExpr = "";
          state.calcResult = "0";
          setCalcStatus("");
          saveState(state);
          renderCalculator();
          return;
        }
        if (key === "⌫") {
          state.calcExpr = (state.calcExpr || "").slice(0, -1);
          saveState(state);
          setCalcResultFromExpr();
          saveState(state);
          return;
        }
        if (key === "=") {
          const r = safeEval(state.calcExpr);
          if (!r.ok) {
            state.calcResult = "ERR";
            setCalcStatus(r.error, "error");
            saveState(state);
            renderCalculator();
            return;
          }
          state.calcExpr = String(r.value);
          state.calcResult = String(r.value);
          setCalcStatus("");
          saveState(state);
          renderCalculator();
          return;
        }

        state.calcExpr = sanitizeExpr((state.calcExpr || "") + key);
        saveState(state);
        setCalcResultFromExpr();
        saveState(state);
      }

      function getCalcNumericResult() {
        const r = safeEval(state.calcExpr);
        if (!r.ok) return { ok: false, error: r.error };
        return { ok: true, value: r.value };
      }

      /* ---------- Mutations / Reference ---------- */

      function actionTypeIcon(actionType) {
        if (actionType === "bonus") return ICONS.bonus;
        if (actionType === "reaction") return ICONS.reaction;
        return ICONS.action;
      }

      function canUseMutation(a) {
        if (a.oncePerShortRest && a.id === "controlled_adaptation" && state.controlledAdaptationUsed) return false;

        if (a.actionType === "action") {
          // special: basic attacks share action, but mutations just need action available
          if (state.actionUsed) return false;
        }
        if (a.actionType === "bonus") {
          if (state.bonusUsed) return false;
        }
        if (a.actionType === "reaction") {
          if (state.reactionUsed) return false;
        }

        const minCost = a.costOptions ? Math.min(...a.costOptions) : (a.cost || 0);
        if (state.ki < minCost) return false;

        return true;
      }

      async function handleMutationUse(a, chosenCost) {
        // economy first
        if (a.actionType === "action") {
          if (!consumeEconomy("action")) {
            setStatus("Action already used this turn.", "error");
            return;
          }
        }
        if (a.actionType === "bonus") {
          if (!consumeEconomy("bonus")) {
            setStatus("Bonus action already used this turn.", "error");
            return;
          }
        }
        if (a.actionType === "reaction") {
          if (!consumeEconomy("reaction")) {
            setStatus("Reaction already used this turn.", "error");
            return;
          }
        }

        // ki spend
        const cost = nint(chosenCost, 0);
        if (!spendKI(cost)) {
          setStatus(`Not enough KI (need ${cost}).`, "error");
          // roll back economy consumption if needed
          if (a.actionType === "action") state.actionUsed = false;
          if (a.actionType === "bonus") state.bonusUsed = false;
          if (a.actionType === "reaction") state.reactionUsed = false;
          return;
        }

        // special effects
        if (a.healsFromMartialDie) {
          const idx = clamp(state.level, 1, 20) - 1;
          const dieStr = MARTIAL_DIE[idx] || "1d4";
          const faces = parseDieFaces(dieStr);
          const roll = rollDie(faces);
          const pb = getProfBonus(state.level);
          const healAmt = roll + pb;
          const healed = applyHeal(healAmt);
          saveState(state);
          await render();
          setStatus(`${a.name}: rolled ${roll} on ${dieStr} + PB ${pb} = ${healAmt}, healed ${healed}.`, "ok");
          return;
        }

        if (a.id === "controlled_adaptation") {
          // once per short rest
          state.controlledAdaptationUsed = true;

          const dmgStr = prompt("Controlled Adaptation: enter incoming damage amount to reduce (number). Leave blank to just roll d100.");
          const roll = rollDie(100);

          if (dmgStr !== null && String(dmgStr).trim() !== "") {
            const dmg = Math.max(0, Number(dmgStr));
            if (!Number.isFinite(dmg)) {
              saveState(state);
              await render();
              setStatus(`Controlled Adaptation: rolled d100 = ${roll}%. (Damage input invalid)`, "ok");
              return;
            }
            const reduced = Math.ceil(dmg * (roll / 100));
            const final = Math.max(0, Math.ceil(dmg - reduced));
            saveState(state);
            await render();
            setStatus(`Controlled Adaptation: rolled ${roll}%, reduced ${reduced} from ${dmg}, final ${final}.`, "ok");
            return;
          }

          saveState(state);
          await render();
          setStatus(`Controlled Adaptation: rolled d100 = ${roll}%.`, "ok");
          return;
        }

        if (a.grantsAcBuff) {
          state.acBuff = Math.max(state.acBuff, nint(a.grantsAcBuff, 0));
          saveState(state);
          await render();
          setStatus(`${a.name} active: AC +${state.acBuff} until Next Turn.`, "ok");
          return;
        }

        saveState(state);
        await render();
        const costText = a.costOptions ? `${cost}` : `${cost}`;
        setStatus(`${a.name} used, spent ${costText} KI.`, "ok");
      }

      function renderAbilities() {
        el.abilityGrid.innerHTML = "";

        const max = getMaxKI(state.level);
        const availableAbilities = KI_ABILITIES.filter(a => state.level >= a.level);

        if (availableAbilities.length === 0) {
          const empty = document.createElement("div");
          empty.className = "sub";
          empty.textContent = "No mutations available yet.";
          el.abilityGrid.appendChild(empty);
          return;
        }

        for (const a of availableAbilities) {
          const card = document.createElement("div");
          card.className = "abilityCard";

          const actWrap = document.createElement("div");
          actWrap.className = "abilityActIcon";
          const actImg = document.createElement("img");
          actImg.alt = `${a.actionType || "action"} icon`;
          actImg.src = PATHS.iconsBase + actionTypeIcon(a.actionType || "action");
          actWrap.appendChild(actImg);

          const iconWrap = document.createElement("div");
          iconWrap.className = "abilityIcon";

          const img = document.createElement("img");
          img.alt = `${a.name} icon`;
          img.onerror = () => { iconWrap.innerHTML = `<div class="missingIcon">Missing icon<br>${a.icon}</div>`; };
          img.src = PATHS.iconsBase + a.icon;
          iconWrap.appendChild(img);

          const mid = document.createElement("div");
          const name = document.createElement("div");
          name.className = "abilityName";
          name.textContent = a.name;

          const meta = document.createElement("div");
          meta.className = "abilityMeta";

          const costMeta = a.costOptions
            ? `Cost: ${a.costOptions[0]} to ${a.costOptions[a.costOptions.length - 1]} KI`
            : `Cost: ${nint(a.cost, 0)} KI`;

          const restMeta = (a.oncePerShortRest) ? " (once per short rest)" : "";
          meta.textContent = costMeta + restMeta;

          mid.appendChild(name);
          mid.appendChild(meta);

          const btns = document.createElement("div");
          btns.className = "abilityBtns";

          let costPicker = null;
          if (a.costOptions && Array.isArray(a.costOptions)) {
            costPicker = document.createElement("select");
            costPicker.setAttribute("aria-label", `Choose KI cost for ${a.name}`);
            for (const c of a.costOptions) {
              const opt = document.createElement("option");
              opt.value = String(c);
              opt.textContent = `${c} KI`;
              costPicker.appendChild(opt);
            }
            btns.appendChild(costPicker);
          }

          const useBtn = document.createElement("button");
          useBtn.className = "btn";
          useBtn.type = "button";
          useBtn.textContent = "Use";
          useBtn.disabled = max === 0;

          useBtn.addEventListener("click", async () => {
            const amt = a.costOptions ? nint(costPicker.value, 0) : nint(a.cost, 0);
            if (!canUseMutation(a)) {
              const reason =
                (a.oncePerShortRest && a.id === "controlled_adaptation" && state.controlledAdaptationUsed) ? "Locked until Short/Long Rest." :
                (a.actionType === "action" && state.actionUsed) ? "Action already used this turn." :
                (a.actionType === "bonus" && state.bonusUsed) ? "Bonus action already used this turn." :
                (a.actionType === "reaction" && state.reactionUsed) ? "Reaction already used this turn." :
                (state.ki < amt) ? `Not enough KI (need ${amt}).` :
                "Unavailable.";
              setStatus(`${a.name}: ${reason}`, "error");
              await render();
              return;
            }
            await handleMutationUse(a, amt);
          });

          const q = document.createElement("button");
          q.className = "qBtn";
          q.type = "button";
          q.textContent = "?";
          q.setAttribute("aria-label", `Show details for ${a.name}`);
          q.addEventListener("click", () => {
            const metaLine = a.costOptions
              ? `Cost: ${a.costOptions[0]} to ${a.costOptions[a.costOptions.length - 1]} KI`
              : `Cost: ${nint(a.cost, 0)} KI`;
            const restLine = a.oncePerShortRest ? "Once per short rest." : "";
            const actionLine = a.actionType ? `Uses: ${a.actionType}` : "Uses: action";
            openDialog(a.name, a.desc, [actionLine, metaLine, restLine].filter(Boolean).join("  |  "));
          });

          btns.appendChild(useBtn);
          btns.appendChild(q);

          card.appendChild(actWrap);
          card.appendChild(iconWrap);
          card.appendChild(mid);
          card.appendChild(btns);

          el.abilityGrid.appendChild(card);
        }

        // refresh disabled states based on economy/ki/rest locks
        const cards = el.abilityGrid.querySelectorAll(".abilityCard");
        cards.forEach((card, i) => {
          const a = availableAbilities[i];
          const useBtn = card.querySelector("button.btn");
          if (!useBtn || !a) return;

          const minCost = a.costOptions ? Math.min(...a.costOptions) : nint(a.cost, 0);
          let ok = true;

          if (state.ki < minCost) ok = false;
          if (a.oncePerShortRest && a.id === "controlled_adaptation" && state.controlledAdaptationUsed) ok = false;
          if (a.actionType === "action" && state.actionUsed) ok = false;
          if (a.actionType === "bonus" && state.bonusUsed) ok = false;
          if (a.actionType === "reaction" && state.reactionUsed) ok = false;

          useBtn.disabled = !ok;
        });
      }

      function renderReference() {
        el.refList.innerHTML = "";
        const available = REF_FEATURES.filter(r => state.level >= r.level);

        if (available.length === 0) {
          const empty = document.createElement("div");
          empty.className = "sub";
          empty.textContent = "No reference items yet.";
          el.refList.appendChild(empty);
          return;
        }

        for (const r of available) {
          const box = document.createElement("div");
          box.className = "refItem";

          const head = document.createElement("div");
          head.className = "refHead";

          const name = document.createElement("div");
          name.className = "refName";
          name.textContent = r.name;

          const lvl = document.createElement("div");
          lvl.className = "refLevel";
          lvl.textContent = `Level ${r.level}`;

          head.appendChild(name);
          head.appendChild(lvl);

          const desc = document.createElement("div");
          desc.className = "refDesc";
          desc.textContent = r.desc;

          box.appendChild(head);
          box.appendChild(desc);

          el.refList.appendChild(box);
        }
      }

      async function render() {
        normalize();
        renderTopStats();
        renderCombat();
        await setBackground();
        renderKIBar();
        renderEconomy();
        renderAbilities();
        renderReference();
        renderCalculator();
        setCalcResultFromExpr();
      }

      function init() {
        el.levelInput = document.getElementById("levelInput");
        el.kiText = document.getElementById("kiText");
        el.kiNumbersText = document.getElementById("kiNumbersText");
        el.moveText = document.getElementById("moveText");
        el.madText = document.getElementById("madText");
        el.kiBar = document.getElementById("kiBar");

        el.spend1 = document.getElementById("spend1");
        el.gain1 = document.getElementById("gain1");
        el.shortRest = document.getElementById("shortRest");
        el.longRest = document.getElementById("longRest");
        el.nextTurn = document.getElementById("nextTurn");
        el.statusBar = document.getElementById("statusBar");

        // action economy
        el.econIcons = document.getElementById("econIcons");
        el.basicAttack = document.getElementById("basicAttack");
        el.oppAttack = document.getElementById("oppAttack");
        el.actionOptions = document.getElementById("actionOptions");
        el.offhandAttack = document.getElementById("offhandAttack");
        el.readiedAttack = document.getElementById("readiedAttack");
        el.readiedInfo = document.getElementById("readiedInfo");

        // Combat
        el.hpNowText = document.getElementById("hpNowText");
        el.hpMaxText = document.getElementById("hpMaxText");
        el.hpTempText = document.getElementById("hpTempText");
        el.acText = document.getElementById("acText");
        el.acBadge = document.getElementById("acBadge");
        el.hpMaxInput = document.getElementById("hpMaxInput");
        el.hpTempInput = document.getElementById("hpTempInput");
        el.acInput = document.getElementById("acInput");
        el.hpFull = document.getElementById("hpFull");
        el.hpZeroTemp = document.getElementById("hpZeroTemp");

        // Calculator
        el.calcExpr = document.getElementById("calcExpr");
        el.calcResult = document.getElementById("calcResult");
        el.calcStatus = document.getElementById("calcStatus");
        el.calcGrid = document.getElementById("calcGrid");
        el.applyAsDamage = document.getElementById("applyAsDamage");
        el.applyAsHeal = document.getElementById("applyAsHeal");
        el.calcCopy = document.getElementById("calcCopy");

        // Mutations/Reference
        el.abilityGrid = document.getElementById("abilityGrid");
        el.refList = document.getElementById("refList");

        // Dialogs
        el.infoDialog = document.getElementById("infoDialog");
        el.dlgTitle = document.getElementById("dlgTitle");
        el.dlgDesc = document.getElementById("dlgDesc");
        el.dlgMeta = document.getElementById("dlgMeta");
        el.dlgClose = document.getElementById("dlgClose");
        el.dlgX = document.getElementById("dlgX");

        el.optionsDialog = document.getElementById("optionsDialog");
        el.optClose = document.getElementById("optClose");
        el.optX = document.getElementById("optX");

        // Load state into inputs
        el.levelInput.value = String(state.level);
        el.hpMaxInput.value = String(state.hpMax);
        el.hpTempInput.value = String(state.hpTemp);
        el.acInput.value = String(state.acBase);

        // Level
        el.levelInput.addEventListener("input", async () => {
          state.level = clamp(nint(el.levelInput.value, 1), 1, 20);
          const newMaxKi = getMaxKI(state.level);
          state.ki = clamp(state.ki, 0, newMaxKi);
          saveState(state);
          setStatus("");
          await render();
        });

        // KI buttons
        el.spend1.addEventListener("click", async () => {
          if (!state.ki) {
            setStatus("Not enough KI.", "error");
            return;
          }
          state.ki = Math.max(0, state.ki - 1);
          saveState(state);
          await render();
          setStatus("Spent 1 KI.", "ok");
        });

        el.gain1.addEventListener("click", async () => {
          const max = getMaxKI(state.level);
          state.ki = Math.min(max, state.ki + 1);
          saveState(state);
          await render();
          setStatus("Gained 1 KI.", "ok");
        });

        el.shortRest.addEventListener("click", () => refillKI(true));
        el.longRest.addEventListener("click", () => refillKI(true));
        el.nextTurn.addEventListener("click", nextTurn);

        // Action economy buttons
        el.basicAttack.addEventListener("click", async () => {
          normalize();
          const ok = useActionAttack();
          if (!ok) {
            setStatus("No attacks remaining this turn.", "error");
            await render();
            return;
          }
          saveState(state);
          await render();
          const maxAttacks = getMaxAttacksPerTurn();
          setStatus(`Basic Attack used (${state.attacksUsed}/${maxAttacks}).`, "ok");
        });

        el.oppAttack.addEventListener("click", async () => {
          normalize();
          if (!consumeEconomy("reaction")) {
            setStatus("Reaction already used this turn.", "error");
            await render();
            return;
          }
          saveState(state);
          await render();
          setStatus("Attack of Opportunity used (reaction).", "ok");
        });

        el.actionOptions.addEventListener("click", () => {
          if (typeof el.optionsDialog.showModal === "function") el.optionsDialog.showModal();
          else alert("Additional options dialog not supported in this browser.");
        });

        el.offhandAttack.addEventListener("click", async () => {
          normalize();
          if (!consumeEconomy("bonus")) {
            setStatus("Bonus action already used this turn.", "error");
            await render();
            return;
          }
          saveState(state);
          await render();
          setStatus("Offhand Attack used (bonus action).", "ok");
        });

        el.readiedAttack.addEventListener("click", async () => {
          normalize();
          if (!consumeEconomy("reaction")) {
            setStatus("Reaction already used this turn.", "error");
            await render();
            return;
          }
          saveState(state);
          await render();
          setStatus("Readied Attack used (reaction).", "ok");
        });

        el.readiedInfo.addEventListener("click", () => {
          openDialog("Readied Attack", READIED_TEXT, "");
        });

        // HP / AC setters
        el.hpMaxInput.addEventListener("input", async () => {
          state.hpMax = Math.max(0, nint(el.hpMaxInput.value, 0));
          state.hpNow = clamp(state.hpNow, 0, state.hpMax);
          saveState(state);
          await render();
        });

        el.hpTempInput.addEventListener("input", async () => {
          state.hpTemp = Math.max(0, nint(el.hpTempInput.value, 0));
          saveState(state);
          await render();
        });

        el.acInput.addEventListener("input", async () => {
          state.acBase = Math.max(0, nint(el.acInput.value, 10));
          saveState(state);
          await render();
        });

        el.hpFull.addEventListener("click", async () => {
          normalize();
          state.hpNow = state.hpMax;
          saveState(state);
          await render();
          setCalcStatus("Healed to full.", "ok");
        });

        el.hpZeroTemp.addEventListener("click", async () => {
          normalize();
          state.hpTemp = 0;
          saveState(state);
          await render();
          setCalcStatus("Temp HP cleared.", "ok");
        });

        // Calculator buttons
        el.calcGrid.addEventListener("click", (e) => {
          const btn = e.target.closest("[data-k]");
          if (!btn) return;
          const k = String(btn.getAttribute("data-k") || "");
          if (!k) return;
          calcPress(k);
        });

        document.addEventListener("keydown", (e) => {
          const k = e.key;
          const tag = (document.activeElement && document.activeElement.tagName) ? document.activeElement.tagName.toLowerCase() : "";
          if (tag === "input" || tag === "select" || tag === "textarea") return;

          if (k >= "0" && k <= "9") return calcPress(k);
          if (k === "+" || k === "-" || k === "*" || k === "/" || k === "." || k === "(" || k === ")") return calcPress(k);
          if (k === "Enter" || k === "=") { e.preventDefault(); return calcPress("="); }
          if (k === "Backspace") { e.preventDefault(); return calcPress("⌫"); }
          if (k === "Escape") return calcPress("C");
        });

        el.applyAsDamage.addEventListener("click", async () => {
          normalize();
          const r = getCalcNumericResult();
          if (!r.ok) { setCalcStatus(r.error, "error"); return; }
          const amt = Math.max(0, Number(r.value));
          const used = applyDamage(amt);
          saveState(state);
          await render();
          setCalcStatus(`Applied ${amt} damage (Temp used: ${used.usedTemp}, HP used: ${used.usedHp}).`, "ok");
        });

        el.applyAsHeal.addEventListener("click", async () => {
          normalize();
          const r = getCalcNumericResult();
          if (!r.ok) { setCalcStatus(r.error, "error"); return; }
          const amt = Math.max(0, Number(r.value));
          const healed = applyHeal(amt);
          saveState(state);
          await render();
          setCalcStatus(`Applied ${healed} healing (capped at Max HP).`, "ok");
        });

        el.calcCopy.addEventListener("click", async () => {
          try {
            await navigator.clipboard.writeText(String(el.calcResult.textContent || "0"));
            setCalcStatus("Result copied to clipboard.", "ok");
          } catch {
            setCalcStatus("Could not copy (browser blocked clipboard).", "error");
          }
        });

        // Info dialog controls
        el.dlgClose.addEventListener("click", () => el.infoDialog.close());
        el.dlgX.addEventListener("click", () => el.infoDialog.close());
        el.infoDialog.addEventListener("click", (e) => {
          const rect = el.infoDialog.getBoundingClientRect();
          const inside =
            e.clientX >= rect.left && e.clientX <= rect.right &&
            e.clientY >= rect.top && e.clientY <= rect.bottom;
          if (!inside) el.infoDialog.close();
        });

        // Options dialog controls
        el.optClose.addEventListener("click", () => el.optionsDialog.close());
        el.optX.addEventListener("click", () => el.optionsDialog.close());
        el.optionsDialog.addEventListener("click", (e) => {
          const rect = el.optionsDialog.getBoundingClientRect();
          const inside =
            e.clientX >= rect.left && e.clientX <= rect.right &&
            e.clientY >= rect.top && e.clientY <= rect.bottom;
          if (!inside) el.optionsDialog.close();
        });

        render();
      }

      document.addEventListener("DOMContentLoaded", init);
    </script>
  </body>
</html>
